<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Matrix Tetris</title>
    <style>
        /* Basic page styling */
        body, html { margin: 0; padding: 0; height: 100%; width: 100%; overflow: hidden; background-color: #000; font-family: 'Consolas', 'Lucida Console', 'Courier New', monospace; user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; touch-action: none; }
        canvas { display: block; position: absolute; top: 0; left: 0; }

        /* Fullscreen prompt styling */
        #fullscreen-prompt { display: none; /* Hide the prompt */ position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: lime; background-color: rgba(0, 0, 0, 0.85); padding: 25px; border: 1px solid lime; font-size: 1.6em; text-align: center; cursor: pointer; z-index: 10; transition: transform 0.05s ease-out, border-color 0.05s ease-out; line-height: 1.4; }
        .version-text { display: block; font-size: 0.5em; opacity: 0.7; margin-top: 15px; }
        .instructions-text { display: block; font-size: 0.45em; opacity: 0.6; margin-top: 10px; line-height: 1.3; text-align: left; /* Align instructions left */ padding-left: 10px; /* Add some padding */ }
        .instructions-text strong { color: #afFaFf; /* Highlight control types */ } /* Style for control type labels */
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="fullscreen-prompt">
        <span id="prompt-main-text">Tap or Press Enter to Start</span><br>
        <span id="prompt-fullscreen-text">(Requires Fullscreen)</span>
        <span class="version-text" id="prompt-version">v1.21</span> <!-- Version bump -->
        <span class="instructions-text" id="prompt-instructions">
            <strong>Controls:</strong><br>
            <strong>Touch:</strong><br>
            &nbsp; Tap Screen: Rotate<br>
            &nbsp; Tap Hold/Next Area: Swap/Ignore<br>
            &nbsp; Slide Finger: Move<br>
            &nbsp; Flick Up/Down: Hard Drop<br>
            <strong>Keyboard:</strong><br>
            &nbsp; ← → : Move<br>
            &nbsp; ↓ : Soft Drop<br>
            &nbsp; ↑ : Hard Drop<br>
            &nbsp; Space: Rotate<br>
            &nbsp; Shift: Hold/Swap<br>
            (Lock Delay Active - No Infinite Spin)
        </span>
    </div>

    <script>
    (function() { // IIFE

        // --- Console, Elements, Context ---
        window.console = window.console || { log: function() {}, error: function() {}, warn: function() {} };
        const canvas = document.getElementById('gameCanvas');
        const promptElement = document.getElementById('fullscreen-prompt');
        const promptMainText = document.getElementById('prompt-main-text');
        const promptFullscreenText = document.getElementById('prompt-fullscreen-text');
        const promptVersionText = document.getElementById('prompt-version');
        const promptInstructionsText = document.getElementById('prompt-instructions');
        const ctx = canvas.getContext('2d');
        if (!canvas || !promptElement || !ctx || !promptMainText || !promptFullscreenText || !promptVersionText || !promptInstructionsText) { alert("CRITICAL ERROR: Elements missing."); return; }
        console.log(">>> Matrix Tetris STARTING <<<");

        // Store original prompt content AFTER elements are confirmed to exist
        const ORIGINAL_PROMPT_MAIN = promptMainText.textContent;
        const ORIGINAL_PROMPT_FS = promptFullscreenText.textContent;
        const ORIGINAL_PROMPT_VERSION = promptVersionText.textContent;
        const ORIGINAL_PROMPT_INSTRUCTIONS = promptInstructionsText.innerHTML;

        // --- Audio Context & Sound ---
        let audioCtx = null;
        function initAudio() { if (!audioCtx && (typeof AudioContext !== 'undefined' || typeof webkitAudioContext !== 'undefined')) { try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); console.log("AudioContext initialized."); } catch (e) { console.error("Error initializing AudioContext:", e); audioCtx = null; } } if (audioCtx && audioCtx.state === 'suspended') { audioCtx.resume().then(() => { console.log("AudioContext resumed!"); }).catch(e => console.error("AudioContext resume failed:", e)); } }
        function playTone(frequency = 440, duration = 50, type = 'square', volume = 0.08) { volume *= 0.9; if (!audioCtx || audioCtx.state === 'suspended') { initAudio(); if (!audioCtx || audioCtx.state !== 'running') { return; } } if (audioCtx.state !== 'running') { return; } try { const o = audioCtx.createOscillator(); const g = audioCtx.createGain(); o.type = type; o.frequency.setValueAtTime(frequency, audioCtx.currentTime); g.gain.setValueAtTime(volume, audioCtx.currentTime); g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration / 1000); o.connect(g); g.connect(audioCtx.destination); o.start(audioCtx.currentTime); o.stop(audioCtx.currentTime + duration / 1000); } catch (e) { console.error("Error playing tone:", e); } }
        const SOUNDS = {
            ROTATE: () => playTone(300, 30, 'triangle', 0.06),
            MOVE: () => playTone(150, 20, 'sine', 0.04),
            LAND: () => playTone(100, 40, 'square', 0.08),
            LINE_CLEAR: () => playTone(600, 100, 'sawtooth', 0.1),
            HARD_DROP: () => playTone(80, 60, 'square', 0.1),
            GAME_OVER: () => { playTone(200, 300, 'sawtooth', 0.15); setTimeout(() => playTone(150, 400, 'sawtooth', 0.15), 150); },
            HOLD_SWAP: () => playTone(450, 70, 'sine', 0.07),
            SOFT_DROP: () => playTone(90, 15, 'square', 0.03),
            TETRIS_CLEAR: () => {
                const baseFreq = 500; const interval = 60; const duration = 80; const vol = 0.12;
                playTone(baseFreq, duration, 'triangle', vol);
                setTimeout(() => playTone(baseFreq * 1.25, duration, 'triangle', vol), interval * 1);
                setTimeout(() => playTone(baseFreq * 1.5, duration, 'triangle', vol), interval * 2);
                setTimeout(() => playTone(baseFreq * 2, duration * 1.5, 'triangle', vol), interval * 3);
            }
        };
        function playStartupSequence() {
            const baseFreq = 300; const freqRange = 600; const beepDuration = 40; const beepVolume = 0.05; const delayBetweenBeeps = 45;
            for (let i = 0; i < 10; i++) { setTimeout(() => { const freq = baseFreq + Math.random() * freqRange; playTone(freq, beepDuration, 'sine', beepVolume); }, i * delayBetweenBeeps); }
        }

        // --- Game Config ---
        let width, height; 
        const boardWidth = 10, boardHeight = 20; 
        let blockSize = 0, boardXOffset = 0; 
        const boardYOffset = 10; 
        let board = [], currentPiece = null, currentRow = 0, currentCol = 0; 
        let score = 0, gameOver = false; 

        // Matrix rain state (needs to be declared before use)
        let matrixStreams = {};

        // --- Tetrominoes & Colors ---
        const PIECES = [ 
            [[1, 1, 1, 1]], 
            [[1, 1], [1, 1]], 
            [[0, 1, 0], [1, 1, 1]], 
            [[0, 1, 1], [1, 1, 0]], 
            [[1, 1, 0], [0, 1, 1]], 
            [[1, 0, 0], [1, 1, 1]], 
            [[0, 0, 1], [1, 1, 1]] 
        ];

        // --- Block Colors (HSL format) ---
        // I: #00FF00 (Lime)
        // O: #00CC00 (Dark Green)
        // T: #66FF66 (Light Green)
        // S: #006600 (Forest Green)
        // Z: #99FF99 (Mint Green)
        // J: #33CC33 (Medium Green)
        // L: #4DFF4D (Bright Green)
        const BASE_COLORS_HSL = [ 
            [120, 60, 50],  // I piece
            [120, 70, 40],  // O piece
            [120, 80, 60],  // T piece
            [120, 50, 30],  // S piece
            [120, 90, 70],  // Z piece
            [120, 65, 45],  // J piece
            [120, 75, 55]   // L piece
        ];

        // --- Visual Settings ---
        const BLOCK_BASE_ALPHA = 0.42;      // Base opacity of blocks
        const GHOST_ALPHA = 0.01;           // Ghost piece opacity
        const GHOST_COLOR = `rgba(120, 255, 120, ${GHOST_ALPHA})`;
        const BLOCK_SHIMMER_SPEED = 0.003;   // Speed of block shimmer effect
        const BLOCK_SHIMMER_AMOUNT = 0.1;    // Intensity of block shimmer
        const BLOCK_FLICKER_CHANCE = 0.0005; // Chance of random block flicker
        const BLOCK_FLICKER_COLOR = 'rgba(255, 255, 255, 0.9)';
        const BOARD_BACKGROUND_COLOR = 'rgba(0, 0, 0, 0.5)'; // Background color for the board area

        // --- Game Speed & Timing Settings ---
        const initialDropInterval = 450;     // Starting time between drops (ms)
        const minDropInterval = 100;         // Fastest possible time between drops (ms)
        const LINES_PER_SPEED_INCREASE = 10; // Lines needed to trigger speed increase
        const SPEED_UP_MULTIPLIER = 0.90;    // How much to multiply interval by when speeding up
        const LOCK_DELAY_DURATION = 500;     // Time before piece locks after landing (ms) [TUNE THIS FOR 'STICKINESS']

        // --- Matrix Background Settings ---
        const MATRIX_GLOBAL_FADE_FACTOR = 0.15;  // Background fade rate
        const MATRIX_BASE_SPEED = 2.5;           // Base speed of matrix rain
        const MATRIX_SPEED_VARIATION = 8.0;      // Random variation in rain speed
        const MATRIX_MIN_FONT_SIZE = 8;          // Smallest matrix character size
        const MATRIX_MAX_FONT_SIZE = 18;         // Largest matrix character size
        const MATRIX_SPAWN_CHANCE_PER_FRAME = 0.07; // Chance of new matrix column per frame
        const MATRIX_COLUMN_WIDTH_MULTIPLIER = 0.9;  // Width of matrix columns
        const MATRIX_TRAIL_MIN_LIGHTNESS = 18;   // Minimum brightness of matrix trail
        const MATRIX_TRAIL_MAX_LIGHTNESS = 55;   // Maximum brightness of matrix trail
        const MATRIX_MAIN_COLOR_HUE = 120;       // Base hue for matrix characters
        const MATRIX_katakana = 'ァアィイゥウェエォオカガキギクグケゲコゴサザシジスズセゼソゾタダチヂッツヅテデトドナニヌネノハバパヒビピフブプヘベペホボポマミムメモャヤュユョヨラリルレロヮワヰヱヲンヴヵヶ';
        const MATRIX_latin = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+-*=<>()[]!?@#$&|:.;^~_';
        const MATRIX_characterPool = (MATRIX_katakana + MATRIX_latin).split(''); // Characters for rain

        // --- UI Settings ---
        const INFO_BOX_WIDTH_PERCENT = 0.15;     // Width of next/hold boxes as % of screen
        const INFO_BOX_HEIGHT_RATIO = 1.0;       // Height ratio of info boxes
        const INFO_BOX_MARGIN = 15;              // Margin around info boxes
        const INFO_BOX_ALPHA = 0.3;              // Opacity of info box background
        const INFO_BOX_BORDER_ALPHA = 0.6;       // Opacity of info box border
        const INFO_BOX_LABEL_ALPHA = 0.8;        // Opacity of info box labels
        const MINI_PIECE_SCALE = 0.6;            // Scale of pieces in info boxes

        // --- Score Display Settings ---
        const SCORE_LINES_Y_MARGIN = 15;         // Vertical margin for score display
        const SCORE_LINES_FONT_SIZE = 20;        // Font size for score display
        const SCORE_GLITCH_CHANCE = 0.05;        // Chance of score text glitch
        const SCORE_GLITCH_INTENSITY = 0.3;      // Intensity of score text glitch
        const SCORE_GLITCH_OFFSET = 2;           // Maximum pixel offset for glitch
        const SCORE_LINES_BG_OPACITY = 0.5;      // Background opacity of score display
        const SCORE_LINES_BG_PADDING_X = 10;     // Horizontal padding for score display
        const SCORE_LINES_BG_PADDING_Y = 4;      // Vertical padding for score display
        const SCORE_LINES_GAP = 20;              // Gap between score and lines display

        // --- Game Over Display Settings ---
        const GAME_OVER_SCORE_FONT_SIZE = 40;    // Font size for final score
        const GAME_OVER_TEXT_FONT_SIZE = 25;     // Font size for game over text

        // --- Prompt Display Settings ---
        const PROMPT_GLITCH_CHANCE = 0.4;        // Chance of prompt text glitch
        const PROMPT_GLITCH_INTENSITY = 0.2;     // Intensity of prompt text glitch
        const PROMPT_JITTER_AMOUNT = 1.5;        // Amount of prompt jitter
        const PROMPT_BORDER_FLICKER_CHANCE = 0.3; // Chance of prompt border flicker
        const PROMPT_BORDER_FLICKER_HUE_SHIFT = 10; // Maximum hue shift for border
        const PROMPT_BORDER_FLICKER_LIGHTNESS_SHIFT = 15; // Maximum lightness shift for border

        // --- Touch Control Settings ---
        const SWIPE_THRESHOLD = 40;              // Minimum distance for swipe detection
        const SWIPE_TIME_LIMIT = 500;            // Maximum time for swipe detection
        const TAP_TIME_LIMIT = 280;              // Maximum time for tap detection
        const TAP_MOVEMENT_THRESHOLD = 30;       // Maximum movement for tap detection
        const SOFT_DROP_START_THRESHOLD = 20;    // Distance to start soft drop
        const SOFT_DROP_MOVE_PER_PIXEL = 0.02;   // Soft drop speed multiplier
        const HORIZONTAL_MOVE_PIXEL_THRESHOLD = 0.7; // Horizontal move sensitivity

        // --- Visual Effect Durations ---
        const FLASH_DURATION = 120;              // Duration of line clear flash
        const SPEED_UP_FLASH_DURATION = 100;     // Duration of speed up flash
        const TETRIS_FLASH_DURATION = 250;       // Duration of tetris clear flash

        // --- Next Piece & Hold Piece Config ---
        let nextPiece = null; let heldPiece = null; let canSwap = true; let nextBoxRect = { x: 0, y: 0, width: 0, height: 0 }; let holdBoxRect = { x: 0, y: 0, width: 0, height: 0 };

        // --- Visuals Config ---
        const TITLE_TEXT = "TETЯIX"; const TITLE_FONT_SIZE_RATIO = 0.1; const TITLE_ALPHA = 0.15; const TITLE_COLOR = 'hsl(120, 40%, 30%)';

        // ===========================================
        // HELPER FUNCTIONS (Stable)
        // ===========================================
        function MATRIX_getRandomChar(pool = MATRIX_characterPool) { return pool[Math.floor(Math.random() * pool.length)]; }
        function glitchText(text, intensity = 0.1, charPool = SCORE_GLITCH_CHARS) { if (!text || text.length === 0 || charPool.length === 0) return text; return text.split('').map(char => (Math.random() < intensity && char !== ' ' && char !== ':' && char !== '\n' && char !== '<' && char !== '>') ? charPool[Math.floor(Math.random() * charPool.length)] : char).join(''); }
        function updatePromptGlitches() { if (!promptElement || promptElement.style.display === 'none') return; if (Math.random() < PROMPT_GLITCH_CHANCE) { promptMainText.textContent = glitchText(ORIGINAL_PROMPT_MAIN, PROMPT_GLITCH_INTENSITY * 1.5); promptFullscreenText.textContent = glitchText(ORIGINAL_PROMPT_FS, PROMPT_GLITCH_INTENSITY * 0.8); promptVersionText.textContent = glitchText(ORIGINAL_PROMPT_VERSION, PROMPT_GLITCH_INTENSITY * 0.5); } else { promptMainText.textContent = ORIGINAL_PROMPT_MAIN; promptFullscreenText.textContent = ORIGINAL_PROMPT_FS; promptVersionText.textContent = ORIGINAL_PROMPT_VERSION; } const jitterX = (Math.random() - 0.5) * 2 * PROMPT_JITTER_AMOUNT; const jitterY = (Math.random() - 0.5) * 2 * PROMPT_JITTER_AMOUNT; promptElement.style.transform = `translate(-50%, -50%) translate(${jitterX}px, ${jitterY}px)`; if (Math.random() < PROMPT_BORDER_FLICKER_CHANCE) { const hueShift = (Math.random() - 0.5) * 2 * PROMPT_BORDER_FLICKER_HUE_SHIFT; const lightShift = (Math.random() - 0.5) * 2 * PROMPT_BORDER_FLICKER_LIGHTNESS_SHIFT; promptElement.style.borderColor = `hsl(${120 + hueShift}, 100%, ${50 + lightShift}%)`; } else { promptElement.style.borderColor = 'lime'; } }
        function resetPromptGlitches() { if (!promptElement) return; promptMainText.textContent = ORIGINAL_PROMPT_MAIN; promptFullscreenText.textContent = ORIGINAL_PROMPT_FS; promptVersionText.textContent = ORIGINAL_PROMPT_VERSION; promptInstructionsText.innerHTML = ORIGINAL_PROMPT_INSTRUCTIONS; promptElement.style.transform = 'translate(-50%, -50%)'; promptElement.style.borderColor = 'lime'; }

        // ===========================================
        // MATRIX BACKGROUND CODE (Stable)
        // ===========================================
        class MATRIX_Character { constructor(x, y, s, f, v, h = false) { this.x = x; this.y = y; this.speed = s; this.fontSize = f; this.value = v || MATRIX_getRandomChar(); this.isHead = h; this.alpha = h ? 1.0 : (0.3 + Math.random() * 0.5); this.hue = MATRIX_MAIN_COLOR_HUE; this.lightness = h ? 65 : MATRIX_TRAIL_MIN_LIGHTNESS + Math.random() * (MATRIX_TRAIL_MAX_LIGHTNESS - MATRIX_TRAIL_MIN_LIGHTNESS); } update() { this.y += this.speed; if (!this.isHead) this.alpha = Math.max(0.01, this.alpha - 0.01); else this.alpha = 1.0; } draw(ctx) { if (!ctx || this.alpha < 0.05 || isNaN(this.x) || isNaN(this.y)) return; const color = `hsla(${this.hue}, 85%, ${this.lightness}%, ${this.alpha})`; try { ctx.fillStyle = color; ctx.font = `${this.fontSize}px monospace`; ctx.fillText(this.value, this.x, this.y); } catch (e) {} if (!this.isHead && Math.random() < 0.015) this.value = MATRIX_getRandomChar(); } }
        class MATRIX_Stream { constructor(x,h){this.x=x;this.streamHeight=h;this.characters=[];this.baseFontSize=Math.floor(Math.random()*(MATRIX_MAX_FONT_SIZE-MATRIX_MIN_FONT_SIZE+1))+MATRIX_MIN_FONT_SIZE;this.speed=MATRIX_BASE_SPEED+Math.random()*MATRIX_SPEED_VARIATION;let iY=-this.baseFontSize*Math.floor(Math.random()*30+15);this.characters.push(new MATRIX_Character(this.x,iY,this.speed,this.baseFontSize,null,true));} spawnNewCharacter(){if(!this.characters.length){this.characters.push(new MATRIX_Character(this.x,0,this.speed,this.baseFontSize,null,true));return}const hC=this.characters[this.characters.length-1];if(!hC)return;const t=this.baseFontSize*(1.0+Math.random()*0.5);if(hC.y>t){try{const nC=new MATRIX_Character(this.x,0,this.speed,this.baseFontSize,null,true);hC.isHead=false;this.characters.push(nC);}catch(e){}}} updateAndDraw(ctx){let a=false;for(let i=this.characters.length-1;i>=0;i--){const c=this.characters[i];if(!c){this.characters.splice(i,1);continue}try{c.update();if(c.y>-this.baseFontSize*5&&c.y<this.streamHeight+this.baseFontSize*5){c.draw(ctx);a=true}if(c.y>this.streamHeight+this.baseFontSize*30||(c.y>this.streamHeight&&c.alpha<0.01)){this.characters.splice(i,1)}else{a=true}}catch(e){this.characters.splice(i,1)}}this.spawnNewCharacter();return this.characters.length===0&&!a;}}
        function MATRIX_setupStreams() { matrixStreams={};const a=(MATRIX_MIN_FONT_SIZE+MATRIX_MAX_FONT_SIZE)/2;const p=a*MATRIX_COLUMN_WIDTH_MULTIPLIER;const n=p>0?Math.ceil(width/p):0;for(let i=0;i<n;i++){const k=i.toString();const x=i*p+(Math.random()*p*0.5-p*0.25);if(!isNaN(x)){try{matrixStreams[k]=new MATRIX_Stream(x,height);}catch(e){}}}}
        function MATRIX_drawGlobalRain(ctx) { if(!ctx||!width||!height)return;let d=[];const a=(MATRIX_MIN_FONT_SIZE+MATRIX_MAX_FONT_SIZE)/2;const p=a*MATRIX_COLUMN_WIDTH_MULTIPLIER;const n=p>0?Math.ceil(width/p):0;for(const k in matrixStreams){if(!Object.prototype.hasOwnProperty.call(matrixStreams,k))continue;const s=matrixStreams[k];if(s){try{if(s.updateAndDraw(ctx))d.push(k);}catch(e){console.error("Stream err:",e);d.push(k);}}else{d.push(k);}}d.forEach(key=>delete matrixStreams[key]);for(let i=0;i<n;i++){const k=i.toString();if(!matrixStreams[k]&&Math.random()<MATRIX_SPAWN_CHANCE_PER_FRAME){const x=i*p+(Math.random()*p*0.5-p*0.25);if(!isNaN(x)){try{matrixStreams[k]=new MATRIX_Stream(x,height);}catch(e){}}}}}

        // ===========================================
        // TETRIS GAME LOGIC (Updated spawnPiece, rotatePiece, movePiece)
        // ===========================================
        function createBoard() { board = Array.from({ length: boardHeight }, () => Array(boardWidth).fill(0)); }
        function getRandomPiece() { const i = Math.floor(Math.random() * PIECES.length); return { shape: PIECES[i], colorIndex: i }; }
        function spawnPiece() {
            currentPiece = nextPiece || getRandomPiece();
            nextPiece = getRandomPiece();
            currentCol = Math.floor(boardWidth / 2) - Math.floor(currentPiece.shape[0].length / 2);
            currentRow = 0; // Start at the very top row
            canSwap = true;
            isLockDelayActive = false; // Reset lock delay status
            lockDelayStartTime = 0;

            if (!isValidMove(currentPiece.shape, currentRow, currentCol)) {
                // *** Check if the spawn position itself is invalid (game over condition) ***
                console.error(`!!! GAME OVER ON SPAWN !!! Piece type: ${currentPiece.colorIndex}, Position: R=${currentRow}, C=${currentCol}. Board state might be invalid.`); // Added log
                gameOver = true;
                isPaused = true;
                SOUNDS.GAME_OVER();
                // Optionally display a more specific game over message if possible
            } else {
                 // Piece spawned successfully
                 lastDropTime = performance.now(); // Reset drop timer only on successful spawn
            }
        }
        function rotateMatrix(matrix) { const r=matrix.length,c=matrix[0].length;const n=Array.from({length:c},()=>Array(r).fill(0));for(let y=0;y<r;y++){for(let x=0;x<c;x++){if(matrix[y][x])n[x][r-1-y]=1;}}return n; }
        function rotatePiece() {
            if (!currentPiece || isPaused || gameOver) return;
            const originalShape = currentPiece.shape;
            const rotatedShape = rotateMatrix(originalShape);
            const kicks = [0, -1, 1, -2, 2]; // Standard kicks

            for (const kick of kicks) {
                if (isValidMove(rotatedShape, currentRow, currentCol + kick)) {
                    currentPiece.shape = rotatedShape;
                    currentCol += kick;
                    SOUNDS.ROTATE();
                    // *** DO NOT reset lock delay timer on rotation ***
                    // if (isLockDelayActive) { lockDelayStartTime = performance.now(); } // REMOVED
                    return; // Rotation successful
                }
            }
            // If loop finishes without returning, rotation failed
        }
        function isValidMove(shape, r, c) {
            for(let y=0; y<shape.length; y++) {
                for(let x=0; x<shape[y].length; x++) {
                    if(shape[y][x]) {
                        let bR = r + y; // Board Row
                        let bC = c + x; // Board Column
                        // Check boundaries and collision with existing blocks
                        if (bR < 0 || bR >= boardHeight || bC < 0 || bC >= boardWidth || board[bR][bC] !== 0) {
                            return false;
                        }
                    }
                }
            }
            return true; // Valid move
        }
        function movePiece(deltaX, deltaY) {
            if (!currentPiece || isPaused || gameOver) return { moved: false, needsLock: false };

            // Prevent downward movement if lock delay is active
            if (deltaY > 0 && isLockDelayActive) {
                return { moved: false, needsLock: true }; // Indicate lock should happen
            }

            if (isValidMove(currentPiece.shape, currentRow + deltaY, currentCol + deltaX)) {
                currentCol += deltaX;
                currentRow += deltaY;

                // If piece moved horizontally *during* lock delay, check if it can now fall.
                // If it can, just cancel the lock delay. Auto-drop will resume naturally.
                if (deltaX !== 0 && isLockDelayActive) {
                    if (isValidMove(currentPiece.shape, currentRow + 1, currentCol)) {
                        isLockDelayActive = false; // Cancel lock delay, allows falling
                        // REMOVED: lastDropTime = performance.now() - (dropInterval + 1);
                        // console.log("Lock delay cancelled by horizontal slide."); // Optional log
                    }
                    // If it still can't fall, the lock delay continues as normal.
                }
                // If piece moved down, cancel any active lock delay anyway
                else if (deltaY > 0) {
                    isLockDelayActive = false;
                }

                // Check if the piece needs to lock *after* the move (only relevant for downward moves)
                const needsLock = deltaY > 0 && !isValidMove(currentPiece.shape, currentRow + 1, currentCol);
                return { moved: true, needsLock: needsLock };
            }

            // If the move failed, check if it failed because it needed to lock (tried moving down)
            if (deltaY > 0 && !isLockDelayActive) {
                // Check if the piece *cannot* move down from its current position
                if (!isValidMove(currentPiece.shape, currentRow + 1, currentCol)) {
                    return { moved: false, needsLock: true }; // Indicate lock should start
                }
            }

            // Move failed for other reasons (e.g., horizontal collision, already at bottom)
            return { moved: false, needsLock: false };
        }
        function hardDrop() {
            if (!currentPiece || isPaused || gameOver) return;

            // If lock delay is already active, just lock it immediately
            if (isLockDelayActive) {
                lockPiece();
                return;
            }

            const ghostR = calculateGhostPosition();
            if (ghostR > currentRow) {
                SOUNDS.HARD_DROP();
                currentRow = ghostR;
                // Immediately trigger lock delay upon landing from hard drop
                // (or just lock it instantly - common variation) Let's trigger delay.
                isLockDelayActive = true;
                lockDelayStartTime = performance.now();
            } else {
                // If ghost is at current row, it means it can't move down, so check if lock delay should start
                if (!isValidMove(currentPiece.shape, currentRow + 1, currentCol)) {
                    if (!isLockDelayActive) {
                        isLockDelayActive = true;
                        lockDelayStartTime = performance.now();
                    }
                } else {
                    // This case (ghostR == currentRow but can move down) shouldn't happen,
                    // but if it does, just lock the piece.
                    lockPiece();
                }
            }
        }
        function softDrop() {
            if (!currentPiece || isPaused || gameOver) return false;
            if (isLockDelayActive) { return false; } // Cannot soft drop during lock phase

            const moveResult = movePiece(0, 1);

            if (moveResult.moved) {
                SOUNDS.SOFT_DROP();
                lastDropTime = performance.now(); // Reset auto-drop timer
                score += 1; // Score for soft dropping
                return true;
            } else if (moveResult.needsLock) {
                // Failed to move down, start lock delay if not already active
                if (!isLockDelayActive) {
                    isLockDelayActive = true;
                    lockDelayStartTime = performance.now();
                }
                return false;
            }
            return false; // Move failed for other reasons
        }
        function lockPiece() {
            if(!currentPiece) return;

            isLockDelayActive = false; // Turn off lock delay
            lockDelayStartTime = 0;
            let pieceLanded = false;

            for(let y=0; y<currentPiece.shape.length; y++) {
                for(let x=0; x<currentPiece.shape[y].length; x++) {
                    if(currentPiece.shape[y][x]) {
                        let bR = currentRow + y;
                        let bC = currentCol + x;
                        // Check if block is within bounds BEFORE accessing board array
                        if (bC >= 0 && bC < boardWidth && bR < boardHeight) {
                             if (bR < 0) {
                                 // Piece locked entirely or partially above the visible board
                                 gameOver = true; // Game over condition
                                 // No need to place blocks if it's game over this way
                             } else {
                                 // Place block on the board
                                 board[bR][bC] = currentPiece.colorIndex + 1;
                                 pieceLanded = true;
                             }
                        }
                        // If bC or bR are out of bounds but not above board,
                        // it implies an invalid state, but game over likely already triggered
                    }
                }
            }

            // Check game over *after* trying to place blocks
            if (gameOver) {
                isPaused = true;
                SOUNDS.GAME_OVER();
                console.log("GAME OVER (Detected in lockPiece)");
                currentPiece = null; // Clear current piece
                return; // Stop further processing
            }

            if (pieceLanded) { // Only play sound and clear lines if placement happened
                 SOUNDS.LAND();
                 const lines = clearLines(); // Check for and clear completed lines
            } else {
                // This case (locking without landing any blocks inside bounds)
                // might indicate an issue or edge case, potentially game over handled above.
                console.warn("lockPiece called but no blocks landed within bounds?");
            }

            // Spawn the next piece (only if not game over)
            spawnPiece();
            // lastDropTime=performance.now(); // Resetting drop timer moved to spawnPiece success case
        }
        function clearLines() {
            let cleared = 0;
            let rowsToClear = [];
            for (let r = boardHeight - 1; r >= 0; r--) {
                if (board[r].every(c => c !== 0)) {
                    cleared++;
                    rowsToClear.push(r);
                }
            }
            // Sort for potentially more predictable visual removal, though splice handles indices ok
            rowsToClear.sort((a, b) => a - b);
            // Remove rows from highest index down to avoid shifting issues
            for (let i = rowsToClear.length - 1; i >= 0; i--) {
                 board.splice(rowsToClear[i], 1);
            }
            // Add new empty rows at the top
            for (let i = 0; i < cleared; i++) {
                board.unshift(Array(boardWidth).fill(0));
            }

            if (cleared > 0) {
                score += cleared * 100 * cleared; // Simple scoring
                totalLinesCleared += cleared;

                if (cleared === 4) { SOUNDS.TETRIS_CLEAR(); tetrisFlashEndTime = performance.now() + TETRIS_FLASH_DURATION; }
                else { SOUNDS.LINE_CLEAR(); flashEndTime = performance.now() + FLASH_DURATION; }

                while (totalLinesCleared >= nextSpeedUpMilestone) {
                    dropInterval = Math.max(minDropInterval, dropInterval * SPEED_UP_MULTIPLIER);
                    nextSpeedUpMilestone += LINES_PER_SPEED_INCREASE;
                    console.log(`--- SPEED UP! Interval: ${dropInterval.toFixed(0)}ms. Next at ${nextSpeedUpMilestone} lines ---`);
                    speedUpFlashEndTime = performance.now() + SPEED_UP_FLASH_DURATION;
                }
            }
            return cleared;
        }
        function calculateGhostPosition() { if(!currentPiece||gameOver)return currentRow;let ghostR=currentRow;while(isValidMove(currentPiece.shape,ghostR+1,currentCol))ghostR++;return ghostR;}
        function swapPiece() { if (isPaused || gameOver || !canSwap) return; SOUNDS.HOLD_SWAP(); isLockDelayActive = false; if (heldPiece === null) { heldPiece = currentPiece; spawnPiece(); } else { let temp = currentPiece; currentPiece = heldPiece; heldPiece = temp; currentCol = Math.floor(boardWidth / 2) - Math.floor(currentPiece.shape[0].length / 2); currentRow = 0; if (!isValidMove(currentPiece.shape, currentRow, currentCol)) { gameOver = true; isPaused = true; SOUNDS.GAME_OVER(); console.log("GAME OVER (Caused by Swap)"); currentPiece = null; } } canSwap = false; // Prevent swapping again until next piece
            // Don't reset lastDropTime here, let spawnPiece handle it
            // lastDropTime = performance.now();
        }

        // ===========================================
        // DRAWING FUNCTIONS (Stable)
        // ===========================================
        function drawBlock(r, c, ci, g = false, t = performance.now(), isMini = false, miniBlockSize = blockSize) { const size = isMini ? miniBlockSize : blockSize; if (size <= 0) return; let a = g ? GHOST_ALPHA : BLOCK_BASE_ALPHA; let fC; const shimmerFactor = Math.sin(t * BLOCK_SHIMMER_SPEED + r + c * 0.5) * BLOCK_SHIMMER_AMOUNT; const currentAlpha = Math.max(g ? GHOST_ALPHA : 0.05, Math.min(1.0, a + (g ? 0 : shimmerFactor))); if (g) { fC = `rgba(120, 255, 120, ${GHOST_ALPHA})`; } else { const [h, s, l] = BASE_COLORS_HSL[ci]; fC = `hsla(${h}, ${s}%, ${l}%, ${currentAlpha})`; } let shouldFlicker = false; if (!g && !isMini && Math.random() < BLOCK_FLICKER_CHANCE) { fC = BLOCK_FLICKER_COLOR; shouldFlicker = true; } ctx.fillStyle = fC; const x = (isMini ? 0 : boardXOffset) + c * size; const y = (isMini ? 0 : boardYOffset) + r * size; ctx.fillRect(x, y, size, size); if (!isMini) { ctx.strokeStyle = shouldFlicker ? 'rgba(100, 255, 100, 0.5)' : (g ? `rgba(200, 255, 200, ${GHOST_ALPHA * 3.5})` : `rgba(0, 0, 0, ${currentAlpha * 0.6})`); ctx.lineWidth = g ? 0.5 : 1; ctx.strokeRect(x + (g ? 0.25 : 0), y + (g ? 0.25 : 0), size - (g ? 0.5 : 0), size - (g ? 0.5 : 0)); } else { ctx.strokeStyle = `rgba(200, 255, 200, ${currentAlpha * 0.3})`; ctx.lineWidth = 0.5; ctx.strokeRect(x+0.5, y+0.5, size-1, size-1); } }
        function drawBoard(timestamp){if(blockSize<=0)return;for(let r=0;r<boardHeight;r++){for(let c=0;c<boardWidth;c++){if(board[r][c]!==0)drawBlock(r,c,board[r][c]-1,false,timestamp);}}ctx.strokeStyle=`hsla(120,50%,20%,${BLOCK_BASE_ALPHA})`;ctx.lineWidth=2;ctx.strokeRect(boardXOffset,boardYOffset,boardWidth*blockSize,boardHeight*blockSize);}
        function drawPiece(shape, r, c, ci, g = false, t){if(blockSize<=0)return;for(let y=0;y<shape.length;y++){for(let x=0;x<shape[y].length;x++){if(shape[y][x])drawBlock(r+y,c+x,ci,g,t);}}}
        function drawMiniPiece(piece, boxRect, timestamp) { if (!piece || !ctx || boxRect.width <= 0) return; const shape = piece.shape; const colorIndex = piece.colorIndex; const pieceHeight = shape.length; const pieceWidth = shape.length > 0 ? shape[0].length : 0; if(pieceWidth === 0) return; const maxDim = Math.max(pieceWidth, pieceHeight, 2); const availableWidth = boxRect.width * MINI_PIECE_SCALE; const availableHeight = boxRect.height * MINI_PIECE_SCALE; const miniBlockSize = Math.max(1, Math.floor(Math.min(availableWidth / maxDim, availableHeight / maxDim))); if (miniBlockSize <= 1) return; const totalPieceWidth = pieceWidth * miniBlockSize; const totalPieceHeight = pieceHeight * miniBlockSize; const startX = boxRect.x + (boxRect.width - totalPieceWidth) / 2; const startY = boxRect.y + (boxRect.height - totalPieceHeight) / 2; ctx.save(); ctx.translate(startX, startY); for (let y = 0; y < pieceHeight; y++) { for (let x = 0; x < pieceWidth; x++) { if (shape[y][x]) { drawBlock(y, x, colorIndex, false, timestamp, true, miniBlockSize); } } } ctx.restore(); }
        function drawInfoBoxes(timestamp) { if (!ctx || blockSize <= 0) return; const boxColor = `rgba(0, 40, 0, ${INFO_BOX_ALPHA})`; const borderColor = `hsla(120, 70%, 50%, ${INFO_BOX_BORDER_ALPHA})`; const labelColor = `hsla(120, 80%, 70%, ${INFO_BOX_LABEL_ALPHA})`; const labelFont = `${Math.max(10, Math.floor(blockSize * 0.6))}px monospace`; ctx.fillStyle = boxColor; ctx.fillRect(nextBoxRect.x, nextBoxRect.y, nextBoxRect.width, nextBoxRect.height); ctx.strokeStyle = borderColor; ctx.lineWidth = 1; ctx.strokeRect(nextBoxRect.x, nextBoxRect.y, nextBoxRect.width, nextBoxRect.height); ctx.fillStyle = labelColor; ctx.font = labelFont; ctx.textAlign = 'center'; ctx.textBaseline = 'top'; ctx.fillText("Next", nextBoxRect.x + nextBoxRect.width / 2, nextBoxRect.y + 5); if (nextPiece) { drawMiniPiece(nextPiece, nextBoxRect, timestamp); } ctx.fillStyle = boxColor; ctx.fillRect(holdBoxRect.x, holdBoxRect.y, holdBoxRect.width, holdBoxRect.height); ctx.strokeStyle = borderColor; ctx.strokeRect(holdBoxRect.x, holdBoxRect.y, holdBoxRect.width, holdBoxRect.height); ctx.fillStyle = labelColor; ctx.fillText("Hold", holdBoxRect.x + holdBoxRect.width / 2, holdBoxRect.y + 5); if (heldPiece) { drawMiniPiece(heldPiece, holdBoxRect, timestamp); } if (!canSwap) { ctx.fillStyle = 'rgba(100, 0, 0, 0.4)'; ctx.fillRect(holdBoxRect.x, holdBoxRect.y, holdBoxRect.width, holdBoxRect.height); } ctx.textAlign = 'left'; ctx.textBaseline = 'alphabetic'; }
        function drawGame(timestamp){
            if (!ctx || blockSize <= 0) return;
            // Draw semi-transparent background for the play area
            ctx.fillStyle = BOARD_BACKGROUND_COLOR;
            ctx.fillRect(boardXOffset, boardYOffset, boardWidth * blockSize, boardHeight * blockSize);
            // Draw the board (blocks already placed)
            drawBoard(timestamp);
            // Draw the current piece, ghost, etc.
            if (currentPiece && !gameOver) {
                const ghostR = calculateGhostPosition();
                if (ghostR > currentRow) { drawPiece(currentPiece.shape, ghostR, currentCol, currentPiece.colorIndex, true, timestamp); }
                drawPiece(currentPiece.shape, currentRow, currentCol, currentPiece.colorIndex, false, timestamp);
            }
        }
        function drawScoreAndLines() { if (!ctx || !width) return; const displayFont = `bold ${SCORE_LINES_FONT_SIZE}px monospace`; ctx.font = displayFont; let scoreStr = `${SCORE_LABEL}${score.toString().padStart(6,'0')}`; let linesStr = `${LINES_LABEL}${totalLinesCleared.toString().padStart(3,'0')}`; let displayScoreStr = scoreStr; let displayLinesStr = linesStr; let displayColor = SCORE_COLOR_BASE; let offsetX = 0, offsetY = 0; if (Math.random() < SCORE_GLITCH_CHANCE) { displayScoreStr = glitchText(scoreStr, SCORE_GLITCH_INTENSITY, SCORE_GLITCH_CHARS); displayLinesStr = glitchText(linesStr, SCORE_GLITCH_INTENSITY, SCORE_GLITCH_CHARS); displayColor = SCORE_COLOR_GLITCH; offsetX = (Math.random() - 0.5) * SCORE_GLITCH_OFFSET * 2; offsetY = (Math.random() - 0.5) * SCORE_GLITCH_OFFSET * 2; } const scoreMetrics = ctx.measureText(displayScoreStr); const linesMetrics = ctx.measureText(displayLinesStr); const totalTextWidth = scoreMetrics.width + SCORE_LINES_GAP + linesMetrics.width; const textHeight = SCORE_LINES_FONT_SIZE; const bgWidth = totalTextWidth + SCORE_LINES_BG_PADDING_X * 2; const bgHeight = textHeight + SCORE_LINES_BG_PADDING_Y * 2; const bgX = width / 2 - bgWidth / 2; const bgY = SCORE_LINES_Y_MARGIN - SCORE_LINES_BG_PADDING_Y; ctx.fillStyle = `rgba(0, 0, 0, ${SCORE_LINES_BG_OPACITY})`; ctx.fillRect(bgX, bgY, bgWidth, bgHeight); ctx.font = displayFont; ctx.fillStyle = displayColor; ctx.textBaseline = 'top'; const drawY = SCORE_LINES_Y_MARGIN + offsetY; const scoreX = bgX + SCORE_LINES_BG_PADDING_X + offsetX; ctx.textAlign = 'left'; try { ctx.fillText(displayScoreStr, scoreX, drawY); } catch(e) {} const linesX = bgX + bgWidth - SCORE_LINES_BG_PADDING_X + offsetX; ctx.textAlign = 'right'; try { ctx.fillText(displayLinesStr, linesX, drawY); } catch(e) {} ctx.textAlign = 'left'; ctx.textBaseline = 'alphabetic'; }
        function drawGameOverScreen(){if(!ctx||!width||!height)return;ctx.font=`bold ${GAME_OVER_SCORE_FONT_SIZE}px monospace`;ctx.fillStyle=SCORE_COLOR_GLITCH;ctx.textAlign='center';ctx.textBaseline='middle';let sStr=score.toString();let dStr=glitchText(sStr,SCORE_GLITCH_INTENSITY*1.5);ctx.fillText(dStr,width/2,height/2);ctx.font=`${GAME_OVER_TEXT_FONT_SIZE}px monospace`;ctx.fillStyle='red';ctx.fillText("GAME OVER",width/2,height/2-GAME_OVER_SCORE_FONT_SIZE*1.2);ctx.fillStyle='white';ctx.fillText("Tap or Press Enter to Restart",width/2,height/2+GAME_OVER_SCORE_FONT_SIZE*0.8);ctx.textAlign='left';}
        function drawTitle() { if (!ctx || !width || !height) return; const fontSize = Math.floor(height * TITLE_FONT_SIZE_RATIO); ctx.font = `bold ${fontSize}px monospace`; ctx.fillStyle = TITLE_COLOR; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; const titleX = width / 2 + (Math.random() - 0.5) * 4; const titleY = height / 2 + (Math.random() - 0.5) * 4; let titleToDraw = TITLE_TEXT; if (Math.random() < 0.03) { titleToDraw = glitchText(TITLE_TEXT, 0.2, ['#', '*', '!', '?']); } ctx.fillText(titleToDraw, titleX, titleY); ctx.textAlign = 'left'; ctx.textBaseline = 'alphabetic'; }

        // ===========================================
        // Game Loop (Updated Logic)
        // ===========================================
        let gameStartTime = 0; let lastFrameTime = 0; const MAX_FPS = 60; const MIN_FRAME_TIME = 1000 / MAX_FPS;
        function gameLoop(timestamp) {
            requestAnimationFrame(gameLoop);
            const elapsed = timestamp - lastFrameTime;
            // Limit frame rate if needed (optional, but good for consistency)
            // if (elapsed < MIN_FRAME_TIME) return;
            lastFrameTime = timestamp;
            const now = performance.now();

            // --- Game Logic Update ---
            if (!isPaused && !gameOver && currentPiece) {
                 // Check Lock Delay first
                 if (isLockDelayActive) {
                     if (now - lockDelayStartTime > LOCK_DELAY_DURATION) {
                        // --- Extended Lock Check (Anti-ledge sticking) ---
                        const canSlideLeft = isValidMove(currentPiece.shape, currentRow, currentCol - 1);
                        const canSlideRight = isValidMove(currentPiece.shape, currentRow, currentCol + 1);
                        const canFallAfterSlideLeft = canSlideLeft && isValidMove(currentPiece.shape, currentRow + 1, currentCol - 1);
                        const canFallAfterSlideRight = canSlideRight && isValidMove(currentPiece.shape, currentRow + 1, currentCol + 1);

                        if (canFallAfterSlideLeft || canFallAfterSlideRight) {
                            // Piece is likely on a ledge. Reset lock delay timer ONLY.
                            // This gives the player more time or waits for the standard auto-drop.
                            lockDelayStartTime = now;
                            // REMOVED: lastDropTime = now;
                            // console.log("Lock delay reset - potential slide detected."); // Optional log
                        } else {
                            // Piece cannot fall from current pos, nor after sliding L/R.
                            lockPiece(); // Lock the piece
                        }
                        // --- End Extended Lock Check ---
                     }
                 }
                 // Automatic Drop (only if lock delay is NOT active)
                 else if (now - lastDropTime > dropInterval) {
                     const moveResult = movePiece(0, 1); // Try to move down
                     if (moveResult.needsLock) {
                         // Could not move down, start lock delay
                         isLockDelayActive = true;
                         lockDelayStartTime = now;
                     } else if (moveResult.moved) {
                         // Successfully moved down, reset drop timer
                         lastDropTime = now;
                     }
                     // If moveResult is {moved: false, needsLock: false}, it means piece hit side wall or similar,
                     // but auto-drop timer should still reset based on `lastDropTime` to prevent instant multi-drops.
                     // However, the check `now - lastDropTime > dropInterval` handles this. Let's reset anyway.
                      else {
                          lastDropTime = now; // Reset timer even if move failed horizontally/vertically without needing lock yet
                      }
                 }
            }

             // --- Drawing ---
             if (isPaused && !gameOver && gameStartTime === 0) {
                 updatePromptGlitches(); // Only update prompt glitches if showing prompt
             }

            // Background Clear / Matrix Rain
            ctx.fillStyle = `rgba(0, 0, 0, ${MATRIX_GLOBAL_FADE_FACTOR})`;
            ctx.fillRect(0, 0, width, height);
            MATRIX_drawGlobalRain(ctx);
            drawTitle(); // Draw title over matrix

            if (gameOver) {
                drawGameOverScreen();
                if (promptElement.style.display !== 'none') { promptElement.style.display = 'none'; resetPromptGlitches(); }
            } else if (isPaused && gameStartTime === 0) {
                // Initial paused state, show prompt
                if (promptElement.style.display === 'none') { promptElement.style.display = 'block'; }
            } else {
                // Game is active (or paused mid-game, though not implemented)
                drawGame(timestamp); // Draws board background, pieces, ghost
                drawInfoBoxes(timestamp);
                drawScoreAndLines();
                if (promptElement.style.display !== 'none') { promptElement.style.display = 'none'; resetPromptGlitches(); }
            }

            // Draw global flash effects last
            if (now < flashEndTime) { ctx.fillStyle = FLASH_COLOR; ctx.fillRect(0, 0, width, height); }
            if (now < speedUpFlashEndTime) { ctx.fillStyle = SPEED_UP_FLASH_COLOR; ctx.fillRect(0, 0, width, height); }
            if (now < tetrisFlashEndTime) { ctx.fillStyle = TETRIS_FLASH_COLOR; ctx.fillRect(0, 0, width, height); }
        }

        // ===========================================
        // Setup & Sizing (Stable)
        // ===========================================
        function calculateSizes() { const availH = height - boardYOffset * 2; const blockFromHeight = availH / boardHeight; const blockFromWidth = width / boardWidth; blockSize = Math.floor(Math.min(blockFromHeight, blockFromWidth)) -1; blockSize = Math.max(5, blockSize); const totalBoardWidth = boardWidth * blockSize; boardXOffset = Math.floor((width - totalBoardWidth) / 2); const scoreHeight = SCORE_LINES_FONT_SIZE + SCORE_LINES_Y_MARGIN; const boxTopY = scoreHeight + INFO_BOX_MARGIN; const boxWidth = Math.floor(width * INFO_BOX_WIDTH_PERCENT); const boxHeight = Math.floor(boxWidth * INFO_BOX_HEIGHT_RATIO); const availableSideSpace = boardXOffset - INFO_BOX_MARGIN; let finalBoxWidth = Math.min(boxWidth, availableSideSpace); let finalBoxHeight = Math.floor(finalBoxWidth * INFO_BOX_HEIGHT_RATIO); const minBoxDim = Math.max(20, blockSize * 3); if (finalBoxWidth < minBoxDim || finalBoxHeight < minBoxDim) { finalBoxWidth = minBoxDim; finalBoxHeight = minBoxDim; const requiredTotalWidth = finalBoxWidth * 2 + totalBoardWidth + INFO_BOX_MARGIN * 2; if (requiredTotalWidth > width) { boardXOffset = Math.floor((width - totalBoardWidth) / 2); } } nextBoxRect = { x: INFO_BOX_MARGIN, y: boxTopY, width: finalBoxWidth, height: finalBoxHeight }; holdBoxRect = { x: width - finalBoxWidth - INFO_BOX_MARGIN, y: boxTopY, width: finalBoxWidth, height: finalBoxHeight }; }
        function setup(isInitialSetup = false) {
             console.log("--- Running Setup ---", "isInitial:", isInitialSetup);
             width = window.innerWidth; height = window.innerHeight; canvas.width = width; canvas.height = height;
             calculateSizes();
             MATRIX_setupStreams();
             createBoard(); // Ensure board is fresh
             score = 0; gameOver = false; dropInterval = initialDropInterval; totalLinesCleared = 0; nextSpeedUpMilestone = LINES_PER_SPEED_INCREASE; flashEndTime = 0; speedUpFlashEndTime = 0; tetrisFlashEndTime = 0; isLockDelayActive = false; lockDelayStartTime = 0; currentPiece = null; nextPiece = getRandomPiece(); // Prepare first next piece
             heldPiece = null; canSwap = true;

             if (isInitialSetup) {
                 isPaused = true; gameStartTime = 0; lastFrameTime = 0;
                 promptElement.style.display = 'block';
                 resetPromptGlitches();
                 console.log("Setup Initial: state set.", {isPaused, gameOver, gameStartTime});
             } else {
                 // Starting a new game
                 console.log("Setup Start Game: attempting to play sequence and set state...");
                 try {
                     playStartupSequence();
                     isPaused = false; // Unpause *before* spawning first piece
                     spawnPiece(); // Spawn the first piece
                     // If spawnPiece immediately caused gameOver, isPaused will be set back to true inside it.
                     if (!gameOver) { // Only set timers if game didn't end on first spawn
                        gameStartTime = performance.now();
                        lastDropTime = gameStartTime;
                        lastFrameTime = gameStartTime;
                     }
                     promptElement.style.display = 'none';
                     resetPromptGlitches();
                     console.log("Setup Start Game: state set.", {isPaused, gameOver, gameStartTime});
                 } catch (error) {
                    console.error("!!!! ERROR DURING setup(false) !!!!", error);
                    isPaused = true; gameOver = true;
                    promptElement.textContent = "Error during startup. Check console.";
                    promptElement.style.display = 'block';
                 }
             }
             console.log(`--- Setup Complete W:${width} H:${height} ---`);
         }

        // ===========================================
        // Fullscreen & Start (Stable)
        // ===========================================
        function requestAppFullscreen() { const e=document.documentElement;if(e.requestFullscreen)return e.requestFullscreen();else if(e.webkitRequestFullscreen)return e.webkitRequestFullscreen();else if(e.msRequestFullscreen)return e.msRequestFullscreen();else return Promise.resolve(); }
        function startGameSequence() {
             console.log(">>> startGameSequence called. Current state:", {isPaused, gameOver, gameStartTime});
             initAudio();
             // Check if the game is already running or over
             if (!isPaused || gameOver || gameStartTime !== 0) {
                 console.warn("Start sequence ignored, game already started or over.", {isPaused, gameOver, gameStartTime});
                 return;
             }
             console.log("Conditions met, starting game directly.");
             // No prompt interaction or fullscreen needed
             setup(false); // Start the game directly
        }

        // ===========================================
        // Touch Controls (Stable)
        // ===========================================
        canvas.addEventListener('touchstart', (e) => { e.preventDefault(); initAudio(); if (gameOver) { setup(false); return; } if (isPaused || !e.touches[0]) return; touchStartX = e.touches[0].clientX; touchStartY = e.touches[0].clientY; touchStartTime = performance.now(); isDraggingDown = false; isDraggingHorizontally = false; lastSoftDropY = touchStartY; lastHorizontalMoveX = touchStartX; horizontalMoveAccumulator = 0; }, { passive: false });
        canvas.addEventListener('touchmove', (e) => { e.preventDefault(); if (isPaused || gameOver || !currentPiece || !e.touches[0]) return; const currentX = e.touches[0].clientX; const currentY = e.touches[0].clientY; const totalDeltaX = currentX - touchStartX; const totalDeltaY = currentY - touchStartY; const instantDeltaX = currentX - lastHorizontalMoveX; const instantDeltaY = currentY - lastSoftDropY; const H_DOMINANT = Math.abs(totalDeltaX) > Math.abs(totalDeltaY) * 1.2 && Math.abs(totalDeltaX) > TAP_MOVEMENT_THRESHOLD / 2; const V_DOMINANT = Math.abs(totalDeltaY) > Math.abs(totalDeltaX) * 1.2 && totalDeltaY > SOFT_DROP_START_THRESHOLD; if (!isDraggingDown && (isDraggingHorizontally || H_DOMINANT)) { if (!isDraggingHorizontally) { isDraggingHorizontally = true; } horizontalMoveAccumulator += instantDeltaX; const effectiveBlockSize = Math.max(10, blockSize); const requiredPixelDrag = effectiveBlockSize * HORIZONTAL_MOVE_PIXEL_THRESHOLD; while (Math.abs(horizontalMoveAccumulator) >= requiredPixelDrag) { const direction = horizontalMoveAccumulator > 0 ? 1 : -1; if (movePiece(direction, 0).moved) { SOUNDS.MOVE(); /* Play move sound on drag */ horizontalMoveAccumulator -= direction * requiredPixelDrag; } else { horizontalMoveAccumulator = 0; break; } } lastHorizontalMoveX = currentX; } else if (!isDraggingHorizontally && (isDraggingDown || V_DOMINANT)) { if (!isDraggingDown) { isDraggingDown = true; } if (!isLockDelayActive) { let pixelsDraggedSinceLastDrop = instantDeltaY; let blocksToDrop = Math.floor(pixelsDraggedSinceLastDrop * SOFT_DROP_MOVE_PER_PIXEL); if (blocksToDrop > 0) { let successfulDrops = 0; for (let i = 0; i < blocksToDrop; i++) { if (softDrop()) { successfulDrops++; } else { break; } } if (successfulDrops > 0) { lastSoftDropY += successfulDrops / SOFT_DROP_MOVE_PER_PIXEL; lastSoftDropY = Math.min(lastSoftDropY, currentY); } } } lastSoftDropY = currentY; /* lastDropTime = performance.now(); // Don't reset auto-drop timer during drag */ } else { lastHorizontalMoveX = currentX; lastSoftDropY = currentY; } }, { passive: false });
        canvas.addEventListener('touchend', (e) => { e.preventDefault(); const wasDraggingDown = isDraggingDown; const wasDraggingHorizontally = isDraggingHorizontally; isDraggingDown = false; isDraggingHorizontally = false; horizontalMoveAccumulator = 0; if (isPaused || gameOver || !e.changedTouches[0]) { return; } const tEndX = e.changedTouches[0].clientX; const tEndY = e.changedTouches[0].clientY; const tEndTime = performance.now(); const dX = tEndX - touchStartX; const dY = tEndY - touchStartY; const elTime = tEndTime - touchStartTime; let actionTaken = false; if (!wasDraggingDown && !wasDraggingHorizontally && elTime < TAP_TIME_LIMIT && Math.abs(dX) < TAP_MOVEMENT_THRESHOLD && Math.abs(dY) < TAP_MOVEMENT_THRESHOLD) { let tappedHold = (holdBoxRect.width > 0 && tEndX >= holdBoxRect.x && tEndX <= holdBoxRect.x + holdBoxRect.width && tEndY >= holdBoxRect.y && tEndY <= holdBoxRect.y + holdBoxRect.height); let tappedNext = (nextBoxRect.width > 0 && tEndX >= nextBoxRect.x && tEndX <= nextBoxRect.x + nextBoxRect.width && tEndY >= nextBoxRect.y && tEndY <= nextBoxRect.y + nextBoxRect.height); if (tappedHold) { swapPiece(); actionTaken = true; } else if (tappedNext) { /* Ignore tap on next box */ actionTaken = false; } else { rotatePiece(); actionTaken = true; } } if (!actionTaken && !wasDraggingDown && !wasDraggingHorizontally && elTime < SWIPE_TIME_LIMIT) { if (Math.abs(dY) > SWIPE_THRESHOLD && Math.abs(dY) > Math.abs(dX) * 1.2) { hardDrop(); actionTaken = true; } } if ((wasDraggingDown || wasDraggingHorizontally) && !actionTaken) { // End of a drag
            // Check if piece is now in a position where it should lock, and start delay if needed
            if (currentPiece && !isLockDelayActive && !isValidMove(currentPiece.shape, currentRow + 1, currentCol)) {
                isLockDelayActive = true;
                lockDelayStartTime = performance.now();
            }
            actionTaken = true;
        } }, { passive: false });

        // ===========================================
        // Keyboard Controls (Stable)
        // ===========================================
        window.addEventListener('keydown', (e) => {
            if (gameOver && e.key === 'Enter') { e.preventDefault(); setup(false); return; }
            if (isPaused || gameOver || !currentPiece) { return; }
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' ', 'Shift', 'w', 'a', 's', 'd'].includes(e.key.toLowerCase()) || e.code === 'Space') { e.preventDefault(); initAudio(); }
            switch (e.key.toLowerCase()) {
                case 'arrowleft':
                case 'a': if (movePiece(-1, 0).moved) SOUNDS.MOVE(); break;
                case 'arrowright':
                case 'd': if (movePiece(1, 0).moved) SOUNDS.MOVE(); break;
                case 'arrowdown':
                case 's': softDrop(); break;
                case 'arrowup':
                case 'w': hardDrop(); break;
                case ' ': case 'spacebar': rotatePiece(); break;
                case 'shift': swapPiece(); break;
            }
        });

        // ===========================================
        // Mouse Controls (New)
        // ===========================================
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault(); // Prevent the context menu from appearing
        });

        canvas.addEventListener('mousedown', (e) => {
            if (isPaused || gameOver || !currentPiece) return;
            
            e.preventDefault();
            initAudio();
            
            if (e.button === 0) { // Left mouse button
                rotatePiece();
            } else if (e.button === 2) { // Right mouse button
                swapPiece();
            }
        });

        // ===========================================
        // Resize & Initial Start (Stable)
        // ===========================================
        window.addEventListener('resize', () => { width = window.innerWidth; height = window.innerHeight; canvas.width = width; canvas.height = height; calculateSizes(); MATRIX_setupStreams(); });

        // --- Initial Setup & Start Game Loop ---
        setup(true);
        requestAnimationFrame(gameLoop);
        // Automatically start the game sequence after initial setup
        // Use a small delay to ensure everything is ready
        setTimeout(startGameSequence, 100);
        console.log(">>> Matrix Tetris Initialized (Paused) <<<");

    })(); // End of IIFE
    </script>
</body>
</html>