<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Matrix Tetris</title>
    <style>
        /* Basic page styling */
        body, html { margin: 0; padding: 0; height: 100%; width: 100%; overflow: hidden; background-color: #000; font-family: 'Consolas', 'Lucida Console', 'Courier New', monospace; user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; touch-action: manipulation; }
        canvas { display: block; position: absolute; top: 0; left: 0; cursor: default; }

        /* Fullscreen prompt styling */
        #fullscreen-prompt { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: lime; background-color: rgba(0, 0, 0, 0.85); padding: 25px; border: 1px solid lime; font-size: 1.6em; text-align: center; cursor: pointer; z-index: 10; transition: transform 0.05s ease-out, border-color 0.05s ease-out; line-height: 1.4; }
        .version-text { display: block; font-size: 0.5em; opacity: 0.7; margin-top: 15px; }
        .instructions-text {
            display: block;
            font-size: 0.45em; /* Smaller base font for instructions */
            opacity: 0.8; /* Slightly more opaque for readability */
            margin-top: 10px;
            line-height: 1.5; /* Increased line height */
            text-align: left;
            padding-left: 10px;
            white-space: pre-line; /* Respect line breaks and wrap */
        }
        .instructions-text strong { color: #afFaFf; display: block; margin-bottom: 3px; /* Space after titles */ } /* Style for control type labels */

        /* High Score Display */
        #highScoreDisplay {
            position: absolute;
            top: 10px;
            /* Changed position to center */
            left: 50%;
            transform: translateX(-50%);
            color: lime; /* Changed color */
            font-size: 16px; /* Adjusted size */
            font-family: 'Consolas', 'Lucida Console', 'Courier New', monospace; /* Ensure font */
            background-color: rgba(0,0,0,0.5);
            padding: 5px;
            z-index: 5; /* Ensure visible above canvas but below pause/game over */
        }

        /* Game Over Overlay */
        #game-over-overlay {
            display: none; /* Hidden by default */
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            color: lime;
            z-index: 20; /* Above everything else */
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 20px;
            box-sizing: border-box;
        }
        #game-over-overlay h2 {
            font-size: 3em;
            color: red;
            margin-bottom: 15px;
            text-shadow: 0 0 5px red;
        }
        #game-over-overlay .stats {
            font-size: 1.5em;
            margin-bottom: 20px;
            line-height: 1.4;
        }
        #game-over-overlay .stats span {
            display: block; /* Each stat on its own line */
            margin-bottom: 5px;
        }

        #game-over-leaderboard-container {
            width: 80%;
            max-width: 450px;
            margin-bottom: 20px;
            background-color: rgba(0, 20, 0, 0.7);
            border: 1px solid lime;
            padding: 10px;
        }
        #game-over-leaderboard-container h3 {
            margin-top: 0; margin-bottom: 10px;
            color: lime; font-size: 1.3em;
        }
        #game-over-leaderboard-scroll {
            max-height: 25vh; /* Limit height and enable scroll */
            overflow-y: auto;
            border: 1px dashed rgba(0, 255, 0, 0.3);
            padding: 5px;
            margin-bottom: 10px;
        }
        #game-over-leaderboard-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9em;
        }
        #game-over-leaderboard-table th, #game-over-leaderboard-table td {
            padding: 3px 6px;
            text-align: left;
            border-bottom: 1px solid rgba(0, 255, 0, 0.2);
        }
        #game-over-leaderboard-table th { color: lime; font-weight: bold; }
        #game-over-leaderboard-table td:nth-child(1) { width: 30px; text-align: right; padding-right: 8px; } /* Rank */
        #game-over-leaderboard-table td:nth-child(3) { text-align: right; font-weight: bold; } /* Score */
        #game-over-leaderboard-table tr:last-child td { border-bottom: none; }

        #save-score-section {
            margin-bottom: 20px;
            display: flex; /* Align items inline */
            align-items: center;
            justify-content: center;
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
            gap: 10px; /* Space between elements */
        }
         #save-score-section label {
             margin-right: 5px;
             font-size: 1.1em;
         }
        #player-name {
            padding: 6px 8px;
            font-family: inherit;
            font-size: 1em;
            background-color: rgba(0, 0, 0, 0.5);
            border: 1px solid lime;
            color: lime;
            width: 150px; /* Adjust width as needed */
        }
        #submit-score-button, #restart-button {
            padding: 8px 15px;
            font-family: inherit;
            font-size: 1.1em;
            background-color: rgba(0, 50, 0, 0.8);
            color: lime;
            border: 1px solid lime;
            cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s;
        }
        #submit-score-button:hover, #restart-button:hover {
            background-color: rgba(0, 80, 0, 1);
            border-color: #ccffcc;
        }
        #submit-score-button:disabled {
            background-color: rgba(50, 0, 0, 0.7);
            color: #ffaaaa;
            border-color: #ff5555;
            cursor: not-allowed;
        }
        #save-status-message {
            display: block; /* Ensure it takes its own line if needed */
            width: 100%; /* Span full width below input/button */
            margin-top: 8px;
            font-size: 0.9em;
            min-height: 1em; /* Reserve space */
            color: #aaffaa;
        }
        #restart-button {
             margin-top: 10px; /* Space above restart button */
             background-color: rgba(50, 50, 0, 0.8); /* Different color? */
        }
        #restart-button:hover {
             background-color: rgba(80, 80, 0, 1);
        }

        /* --- OLD Save Score Button Styles REMOVED --- */

        /* Basic page styling (repeated, keep one) */
        /* body, html { margin: 0; padding: 0; height: 100%; width: 100%; overflow: hidden; background-color: #000; font-family: 'Consolas', 'Lucida Console', 'Courier New', monospace; user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; touch-action: manipulation; } */
        /* canvas { display: block; position: absolute; top: 0; left: 0; cursor: default; } */

        /* Fullscreen prompt styling (repeated, keep one) */
        /* #fullscreen-prompt { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: lime; background-color: rgba(0, 0, 0, 0.85); padding: 25px; border: 1px solid lime; font-size: 1.6em; text-align: center; cursor: pointer; z-index: 10; transition: transform 0.05s ease-out, border-color 0.05s ease-out; line-height: 1.4; } */
        /* .version-text { display: block; font-size: 0.5em; opacity: 0.7; margin-top: 15px; } */
        /* .instructions-text { ... } */
        /* .instructions-text strong { ... } */
    </style>

    <!-- Firebase SDK -->
    <!-- update the version number as needed -->
    <script defer src="/__/firebase/10.12.4/firebase-app-compat.js"></script>
    <!-- include only the Firebase features as you need -->
    <!-- <script defer src="/__/firebase/10.12.4/firebase-auth-compat.js"></script> -->
    <!-- <script defer src="/__/firebase/10.12.4/firebase-database-compat.js"></script> -->
    <script defer src="/__/firebase/10.12.4/firebase-firestore-compat.js"></script>
    <!-- <script defer src="/__/firebase/10.12.4/firebase-functions-compat.js"></script> -->
    <!-- <script defer src="/__/firebase/10.12.4/firebase-messaging-compat.js"></script> -->
    <!-- <script defer src="/__/firebase/10.12.4/firebase-storage-compat.js"></script> -->
    <!-- <script defer src="/__/firebase/10.12.4/firebase-analytics-compat.js"></script> -->
    <!-- <script defer src="/__/firebase/10.12.4/firebase-remote-config-compat.js"></script> -->
    <!-- <script defer src="/__/firebase/10.12.4/firebase-performance-compat.js"></script> -->
    <!--
      initialize the SDK after all desired features are loaded, set useEmulator to false
      to avoid connecting the SDK to running emulators.
    -->
    <script defer src="/__/firebase/init.js?useEmulator=true"></script>

</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="fullscreen-prompt">
        <span id="prompt-main-text">Tap or Press Enter to Start</span><br>
        <span id="prompt-fullscreen-text">(Requires Fullscreen)</span>
        <span class="version-text" id="prompt-version">v1.36</span> <!-- Version bump -->
        <span class="instructions-text" id="prompt-instructions">
             <!-- Content set by JS with newlines -->
        </span>
    </div>
    <div id="highScoreDisplay">High Score: 0</div>

    <!-- Game Over Overlay (New) -->
    <div id="game-over-overlay">
        <h2 id="game-over-title">GAME OVER</h2>
        <div class="stats">
            <span id="game-over-score">Score: 0</span>
            <span id="game-over-lines">Lines: 0</span>
            <span id="game-over-highscore">High Score: 0</span>
        </div>

        <div id="game-over-leaderboard-container">
            <h3>Leaderboard (Top 100)</h3>
            <div id="game-over-leaderboard-scroll">
                <table id="game-over-leaderboard-table">
                    <tbody id="game-over-leaderboard-body">
                        <!-- Scores loaded by JS -->
                        <tr><td colspan="3" style="text-align: center;">Loading...</td></tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div id="save-score-section">
            <label for="player-name">Name:</label>
            <input type="text" id="player-name" name="player-name" maxlength="15" placeholder="Enter Name">
            <button id="submit-score-button">Save Score</button>
        </div>
        <p id="save-status-message"></p>

        <button id="restart-button">Restart Game</button>
    </div>

    <script>
    (function() { // IIFE

        // --- Console, Elements, Context ---
        window.console = window.console || { log: function() {}, error: function() {}, warn: function() {} };
        const canvas = document.getElementById('gameCanvas');
        const promptElement = document.getElementById('fullscreen-prompt');
        const promptMainText = document.getElementById('prompt-main-text');
        const promptFullscreenText = document.getElementById('prompt-fullscreen-text');
        const promptVersionText = document.getElementById('prompt-version');
        const promptInstructionsText = document.getElementById('prompt-instructions');
        const highScoreDisplayElement = document.getElementById('highScoreDisplay'); // Added High Score Element
        // Added Game Over Overlay Elements
        const gameOverOverlay = document.getElementById('game-over-overlay');
        const gameOverScoreEl = document.getElementById('game-over-score');
        const gameOverLinesEl = document.getElementById('game-over-lines');
        const gameOverHighscoreEl = document.getElementById('game-over-highscore');
        const gameOverLeaderboardBody = document.getElementById('game-over-leaderboard-body');
        const playerNameInput = document.getElementById('player-name');
        const submitScoreButton = document.getElementById('submit-score-button');
        const saveStatusMessage = document.getElementById('save-status-message');
        const restartButton = document.getElementById('restart-button');
        const saveScoreSection = document.getElementById('save-score-section'); // Added save score section retrieval

        const ctx = canvas.getContext('2d');
        // Updated check to include new overlay elements AND saveScoreSection
        if (!canvas || !promptElement || !ctx || !promptMainText || !promptFullscreenText || !promptVersionText || !promptInstructionsText || !highScoreDisplayElement ||
            !gameOverOverlay || !gameOverScoreEl || !gameOverLinesEl || !gameOverHighscoreEl || !gameOverLeaderboardBody || !playerNameInput || !submitScoreButton || !saveStatusMessage || !restartButton || !saveScoreSection) { // Added saveScoreSection check
            alert("CRITICAL ERROR: Elements missing.");
            return;
        }
        console.log(">>> Matrix Tetris STARTING <<<");

        const ORIGINAL_PROMPT_MAIN = promptMainText.textContent;
        const ORIGINAL_PROMPT_FS = promptFullscreenText.textContent;
        const ORIGINAL_PROMPT_VERSION = promptVersionText.textContent;
        const ORIGINAL_PROMPT_INSTRUCTIONS = `<strong>Controls:</strong>
<strong>Keyboard:</strong>
 P: Pause
 ← → : Move
 ↓ : Soft Drop
 ↑ : Hard Drop
 Space: Rotate
 Shift: Hold/Swap

<strong>Touch:</strong>
 Bottom-Left Icon: Pause
 Tap Screen: Rotate
 Tap Hold/Next Area: Swap/Ignore
 Slide Finger: Move
 Flick Up/Down: Hard Drop

(Lock Delay Active - No Infinite Spin)`;

        // Set initial instruction text
        promptInstructionsText.innerHTML = ORIGINAL_PROMPT_INSTRUCTIONS;


        // --- Audio Context & Sound ---
        let audioCtx = null;
        function initAudio() { if (!audioCtx && (typeof AudioContext !== 'undefined' || typeof webkitAudioContext !== 'undefined')) { try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); console.log("AudioContext initialized."); } catch (e) { console.error("Error initializing AudioContext:", e); audioCtx = null; } } if (audioCtx && audioCtx.state === 'suspended') { audioCtx.resume().then(() => { console.log("AudioContext resumed!"); }).catch(e => console.error("AudioContext resume failed:", e)); } }
        function playTone(frequency = 440, duration = 50, type = 'square', volume = 0.08) {
            if (!settings_sfxEnabled) return;
            volume *= 0.9; if (!audioCtx || audioCtx.state === 'suspended') { initAudio(); if (!audioCtx || audioCtx.state !== 'running') { return; } } if (audioCtx.state !== 'running') { return; } try { const o = audioCtx.createOscillator(); const g = audioCtx.createGain(); o.type = type; o.frequency.setValueAtTime(frequency, audioCtx.currentTime); g.gain.setValueAtTime(volume, audioCtx.currentTime); g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration / 1000); o.connect(g); g.connect(audioCtx.destination); o.start(audioCtx.currentTime); o.stop(audioCtx.currentTime + duration / 1000); } catch (e) { console.error("Error playing tone:", e); } }
        const SOUNDS = { ROTATE: () => playTone(300, 30, 'triangle', 0.06), MOVE: () => playTone(150, 20, 'sine', 0.04), LAND: () => playTone(100, 40, 'square', 0.08), LINE_CLEAR: () => playTone(600, 100, 'sawtooth', 0.1), HARD_DROP: () => playTone(80, 60, 'square', 0.1), GAME_OVER: () => { playTone(200, 300, 'sawtooth', 0.15); setTimeout(() => playTone(150, 400, 'sawtooth', 0.15), 150); }, HOLD_SWAP: () => playTone(450, 70, 'sine', 0.07), SOFT_DROP: () => playTone(90, 15, 'square', 0.03), TETRIS_CLEAR: () => { const b = 500, i = 60, d = 80, v = 0.12; playTone(b, d, 'triangle', v); setTimeout(() => playTone(b * 1.25, d, 'triangle', v), i * 1); setTimeout(() => playTone(b * 1.5, d, 'triangle', v), i * 2); setTimeout(() => playTone(b * 2, d * 1.5, 'triangle', v), i * 3); }, UI_CLICK: () => playTone(500, 25, 'sine', 0.05), PAUSE_ON: () => playTone(350, 50, 'sine', 0.07), PAUSE_OFF: () => playTone(550, 50, 'sine', 0.07), };
        function playStartupSequence() { const b = 300, r = 600, d = 40, v = 0.05, dl = 45; for (let i = 0; i < 10; i++) { setTimeout(() => { const f = b + Math.random() * r; playTone(f, d, 'sine', v); }, i * dl); } }

        // --- Game Config ---
        let width, height; const boardWidth = 10, boardHeight = 20; let blockSize = 0, boardXOffset = 0; const boardYOffset = 10; let board = [], currentPiece = null, currentRow = 0, currentCol = 0;
        let score = 0, totalLinesCleared = 0, highScore = 0;
        let gameOver = false; let isPaused = true;
        let matrixStreams = {};

        // --- Tetrominoes & Colors ---
        const PIECES = [ [[1, 1, 1, 1]], [[1, 1], [1, 1]], [[0, 1, 0], [1, 1, 1]], [[0, 1, 1], [1, 1, 0]], [[1, 1, 0], [0, 1, 1]], [[1, 0, 0], [1, 1, 1]], [[0, 0, 1], [1, 1, 1]] ];
        const BASE_COLORS_HSL = [ [120, 60, 50], [120, 70, 40], [120, 80, 60], [120, 50, 30], [120, 90, 70], [120, 65, 45], [120, 75, 55] ];

        // --- Settings ---
        let settings_ghostAlpha = 0.05;
        let settings_useWireframeBlocks = false;
        let settings_sfxEnabled = true;
        let settings_boardBackgroundAlpha = 0.5;

        // --- Visual Settings ---
        const BLOCK_BASE_ALPHA = 0.42; const BLOCK_SHIMMER_SPEED = 0.003; const BLOCK_SHIMMER_AMOUNT = 0.1; const BLOCK_FLICKER_CHANCE = 0.0005; const BLOCK_FLICKER_COLOR = 'rgba(255, 255, 255, 0.9)';

        // --- Game Speed & Timing ---
        const initialDropInterval = 450; let dropInterval = initialDropInterval; const minDropInterval = 100; const LINES_PER_SPEED_INCREASE = 10; const SPEED_UP_MULTIPLIER = 0.90; const LOCK_DELAY_DURATION = 500;
        let lastDropTime = 0; let lockDelayStartTime = 0; let isLockDelayActive = false; let nextSpeedUpMilestone = LINES_PER_SPEED_INCREASE;

        // --- Matrix Background ---
        const MATRIX_FIXED_SPAWN_CHANCE = 0.07; const MATRIX_GLOBAL_FADE_FACTOR = 0.15; const MATRIX_BASE_SPEED = 2.5; const MATRIX_SPEED_VARIATION = 8.0; const MATRIX_MIN_FONT_SIZE = 8; const MATRIX_MAX_FONT_SIZE = 18; const MATRIX_COLUMN_WIDTH_MULTIPLIER = 0.9; const MATRIX_TRAIL_MIN_LIGHTNESS = 18; const MATRIX_TRAIL_MAX_LIGHTNESS = 55; const MATRIX_MAIN_COLOR_HUE = 120;
        const MATRIX_katakana = 'ァアィイゥウェエォオカガキギクグケゲコゴサザシジスズセゼソゾタダチヂッツヅテデトドナニヌネノハバパヒビピフブプヘベペホボポマミムメモャヤュユョヨラリルレロヮワヰヱヲンヴヵヶ'; const MATRIX_latin = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+-*=<>()[]!?@#$&|:.;^~_'; const MATRIX_characterPool = (MATRIX_katakana + MATRIX_latin).split('');

        // --- UI Settings ---
        const INFO_BOX_MARGIN = 5; const INFO_BOX_ALPHA = 0.3; const INFO_BOX_BORDER_ALPHA = 0.6; const INFO_BOX_LABEL_ALPHA = 0.8; const MINI_PIECE_SCALE = 0.7;
        const SETTINGS_ICON_SIZE = 30; const SETTINGS_ICON_MARGIN = 15;
        let settingsButtonRect = { x: 0, y: 0, width: 0, height: 0 }; let pauseMenuCloseButtonRect = { x: 0, y: 0, width: 0, height: 0 };
        const SCORE_LINES_Y_MARGIN = 15; const SCORE_LINES_FONT_SIZE = 20; const SCORE_GLITCH_CHANCE = 0.05; const SCORE_GLITCH_INTENSITY = 0.3; const SCORE_GLITCH_OFFSET = 2; const SCORE_LINES_BG_OPACITY = 0.5; const SCORE_LINES_BG_PADDING_X = 10; const SCORE_LINES_BG_PADDING_Y = 4; const SCORE_LINES_GAP = 25; const SCORE_LABEL = "SCORE:"; const LINES_LABEL = "LINES:"; const SCORE_COLOR_BASE = 'hsl(120, 100%, 75%)'; const SCORE_COLOR_GLITCH = 'hsl(100, 100%, 85%)'; const SCORE_GLITCH_CHARS = MATRIX_characterPool;
        const GAME_OVER_TITLE_FONT_SIZE = 50; const GAME_OVER_STATS_FONT_SIZE = 30; const GAME_OVER_SUBTEXT_FONT_SIZE = 20;
        // <-- Pause Menu Constants (Adjusted Again) -->
        const PAUSE_MENU_BG_ALPHA = 0.85; const PAUSE_MENU_TEXT_COLOR = 'lime';
        const PAUSE_MENU_TITLE_FONT_SIZE = 32;
        const PAUSE_MENU_ITEM_FONT_SIZE = 18;
        const PAUSE_MENU_VALUE_FONT_SIZE = 16;
        const PAUSE_MENU_ITEM_GAP = 55; // <<< INCREASED FURTHER from 45 for more spacing
        const PAUSE_MENU_SLIDER_WIDTH_RATIO = 0.5;
        const PAUSE_MENU_SLIDER_HEIGHT = 12;
        const PAUSE_MENU_SLIDER_HANDLE_SIZE = 18;
        const PAUSE_MENU_BUTTON_PADDING_X = 12; const PAUSE_MENU_BUTTON_PADDING_Y = 6;
        const PAUSE_MENU_CLOSE_BUTTON_SIZE = 30;
        const PAUSE_MENU_CLOSE_BUTTON_MARGIN = 12;
        let pauseMenuElements = {}; let activeSlider = null;
        let pauseMenuInitialized = false; // Flag to initialize elements once
        let pauseLeaderboardData = null; // <<< ADDED: To store leaderboard scores for pause menu
        let pauseLeaderboardScrollY = 0; // <<< ADDED: Scroll position for pause leaderboard
        let activeScrollArea = null; // <<< ADDED: To track if dragging inside leaderboard

        // --- Touch Controls ---
        const SWIPE_THRESHOLD = 40; // <<< REVERTED from 80
        const SWIPE_TIME_LIMIT = 500;
        const TAP_TIME_LIMIT = 280;
        const TAP_MOVEMENT_THRESHOLD = 30; // <<< REVERTED from 60
        const SOFT_DROP_START_THRESHOLD = 20;
        const SOFT_DROP_MOVE_PER_PIXEL = 0.02;
        const HORIZONTAL_MOVE_PIXEL_THRESHOLD = 0.7; // <<< REVERTED from 0.9
        let touchStartX = 0, touchStartY = 0, touchStartTime = 0; let isDraggingDown = false, isDraggingHorizontally = false; let lastSoftDropY = 0, lastHorizontalMoveX = 0; let horizontalMoveAccumulator = 0; let touchIdentifier = null;

        // --- Visual Effects ---
        const FLASH_DURATION = 120; const SPEED_UP_FLASH_DURATION = 100; const TETRIS_FLASH_DURATION = 250; let flashEndTime = 0, speedUpFlashEndTime = 0, tetrisFlashEndTime = 0;
        const FLASH_COLOR = 'rgba(180, 255, 180, 0.3)'; const SPEED_UP_FLASH_COLOR = 'rgba(255, 255, 100, 0.4)'; const TETRIS_FLASH_COLOR = 'rgba(150, 150, 255, 0.5)';

        // --- Game State ---
        let nextPiece = null; let heldPiece = null; let canSwap = true; let nextBoxRect = { x: 0, y: 0, width: 0, height: 0 }; let holdBoxRect = { x: 0, y: 0, width: 0, height: 0 };

        // --- Visuals ---
        const TITLE_TEXT = "TETЯIX"; const TITLE_FONT_SIZE_RATIO = 0.1; const TITLE_ALPHA = 0.15; const TITLE_COLOR = 'hsl(120, 40%, 30%)';

        // --- Firestore Database --- (Added)
        let db = null;

        // ===========================================
        // LOCAL STORAGE FUNCTIONS (Restored for non-score settings)
        // ===========================================
        const LS_PREFIX = 'matrixTetris_';
        function saveToLocalStorage(key, value) { try { localStorage.setItem(LS_PREFIX + key, JSON.stringify(value)); } catch (e) { console.error("LocalStorage Save Error:", e); } }
        function loadFromLocalStorage(key, defaultValue) { try { const storedValue = localStorage.getItem(LS_PREFIX + key); return storedValue !== null ? JSON.parse(storedValue) : defaultValue; } catch (e) { console.error("LocalStorage Load Error:", e); return defaultValue; } }

        // --- Firestore High Score Functions --- (Added)
        async function loadHighScoreFromFirestore() {
            if (!db) {
                console.error("DB not ready in loadHighScoreFromFirestore. Cannot load high score.");
                highScoreDisplayElement.textContent = `High Score: Error`;
                return;
            }
            console.log("Attempting to load high score from Firestore...");
            try {
                const docRef = firebase.firestore().collection("scores").doc("highScore");
                const doc = await docRef.get();
                if (doc.exists) {
                    highScore = doc.data().score;
                    highScoreDisplayElement.textContent = `High Score: ${highScore}`;
                    console.log("Firestore high score loaded:", highScore);
                } else {
                    console.log("No high score document in Firestore, starting fresh.");
                    highScore = 0;
                    highScoreDisplayElement.textContent = `High Score: 0`;
                    // Optionally create the document if it doesn't exist
                    await docRef.set({ score: 0 });
                    console.log("Created initial high score document in Firestore.");
                }
            } catch (error) {
                console.error("Error getting high score from Firestore: ", error); // Log specific error
                highScore = 0; // Default to 0 on error
                highScoreDisplayElement.textContent = `High Score: Error`; // Show error state
            }
        }

        async function saveHighScoreToFirestore() {
            if (!db) {
                console.warn("DB not ready in saveHighScoreToFirestore. Cannot save high score.");
                return;
            }
            if (score > highScore) {
                highScore = score; // Update local high score variable
                highScoreDisplayElement.textContent = `High Score: ${highScore}`; // Update display
                const docRef = db.collection("scores").doc("highScore");
                try {
                    await docRef.set({ score: highScore });
                    console.log("New high score saved to Firestore:", highScore);
                } catch (error) {
                    console.error("Error saving high score to Firestore: ", error); // Log specific error
                    // Optionally inform the user about the failure
                }
            }
        }

        // Modified loadSettings - checks for firebase and attempts to get db
        function loadSettings() {
            // Load other settings from local storage as before
            settings_ghostAlpha = clamp(loadFromLocalStorage('ghostAlpha', 0.05), 0.01, 0.10);
            settings_useWireframeBlocks = loadFromLocalStorage('useWireframeBlocks', false);
            settings_sfxEnabled = loadFromLocalStorage('sfxEnabled', true);
            settings_boardBackgroundAlpha = clamp(loadFromLocalStorage('boardBackgroundAlpha', 0.5), 0.10, 1.0);
            console.log("Non-score settings Loaded:", { settings_ghostAlpha, settings_useWireframeBlocks, settings_sfxEnabled, settings_boardBackgroundAlpha });

            // Get Firestore instance (assuming init.js handled initialization)
            console.log("loadSettings: Checking Firebase availability...");
            if (typeof firebase !== 'undefined' && typeof firebase.firestore === 'function') {
                 console.log(`   Firebase found. Apps length: ${firebase.apps.length}`);
                try {
                    db = firebase.firestore();
                    console.log("   Firestore instance obtained: ", db ? "Success" : "Failed");
                    if(db) {
                        loadHighScoreFromFirestore(); // Load score immediately if db obtained
                    } else {
                        highScoreDisplayElement.textContent = "High Score: Error (DB null)";
                    }
                } catch (e) {
                    console.error("   Error accessing Firestore: ", e); // Log specific error
                    db = null; // Ensure db is null on error
                    highScoreDisplayElement.textContent = "High Score: Error (Catch)";
                }
            } else {
                console.warn("   Firebase or Firestore not available when loadSettings called.");
                highScoreDisplayElement.textContent = "High Score: Error (No FB)";
                // We will try again in setup(false) if game starts
            }
        }

        // Save non-score settings (score saved separately via Firestore function)
        function saveSettings() {
             // saveToLocalStorage('highScore', highScore); // REMOVED
             // Calls below should work now
             saveToLocalStorage('ghostAlpha', settings_ghostAlpha);
             saveToLocalStorage('useWireframeBlocks', settings_useWireframeBlocks);
             saveToLocalStorage('sfxEnabled', settings_sfxEnabled);
             saveToLocalStorage('boardBackgroundAlpha', settings_boardBackgroundAlpha);
        }

        // Firestore saveHighScoreToFirestore handles the score saving now.

        // ===========================================
        // HELPER FUNCTIONS
        // ===========================================
        function MATRIX_getRandomChar(pool = MATRIX_characterPool) { return pool[Math.floor(Math.random() * pool.length)]; }
        function glitchText(text, intensity = 0.1, charPool = SCORE_GLITCH_CHARS) { if (!text || text.length === 0 || charPool.length === 0) return text; return text.split('').map(char => (Math.random() < intensity && char !== ' ' && char !== ':' && char !== '\n' && char !== '<' && char !== '>') ? charPool[Math.floor(Math.random() * charPool.length)] : char).join(''); }
        function updatePromptGlitches() {
             if (!promptElement || promptElement.style.display === 'none') return;
             if (Math.random() < 0.4) {
                 promptVersionText.textContent = glitchText(ORIGINAL_PROMPT_VERSION, 0.1);
             } else {
                 promptMainText.textContent = ORIGINAL_PROMPT_MAIN;
                 promptFullscreenText.textContent = ORIGINAL_PROMPT_FS;
                 promptVersionText.textContent = ORIGINAL_PROMPT_VERSION;
             }
             const jX = (Math.random() - 0.5) * 3; const jY = (Math.random() - 0.5) * 3; promptElement.style.transform = `translate(-50%, -50%) translate(${jX}px, ${jY}px)`;
             if (Math.random() < 0.3) { const hS = (Math.random() - 0.5) * 20; const lS = (Math.random() - 0.5) * 30; promptElement.style.borderColor = `hsl(${120 + hS}, 100%, ${50 + lS}%)`; } else { promptElement.style.borderColor = 'lime'; }
         }
        function resetPromptGlitches() { if (!promptElement) return; promptMainText.textContent = ORIGINAL_PROMPT_MAIN; promptFullscreenText.textContent = ORIGINAL_PROMPT_FS; promptVersionText.textContent = ORIGINAL_PROMPT_VERSION; promptInstructionsText.innerHTML = ORIGINAL_PROMPT_INSTRUCTIONS; promptElement.style.transform = 'translate(-50%, -50%)'; promptElement.style.borderColor = 'lime'; }
        function isPointInRect(x, y, rect) { return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height; }
        function clamp(value, min, max) { return Math.min(Math.max(value, min), max); }
        function resumeGame() { if (!isPaused || gameOver) return; isPaused = false; if (gameStartTime > 0) { const d = performance.now() - (lastFrameTime || gameStartTime); lastDropTime += d; if (isLockDelayActive) lockDelayStartTime += d; } SOUNDS.PAUSE_OFF(); }
        function pauseGame() { if (isPaused || gameOver) return; isPaused = true; activeSlider = null; activeScrollArea = null; // Reset scroll tracking
            pauseLeaderboardScrollY = 0; // Reset scroll position
            if (!pauseMenuInitialized) {
                initializePauseMenuElements();
                pauseMenuInitialized = true;
            }
            loadPauseMenuLeaderboard(); // <<< ADDED: Load leaderboard data when pausing
            SOUNDS.PAUSE_ON();
        }
        function togglePause() {
             if (gameOver || gameStartTime === 0) return;
             if (isPaused) {
                 resumeGame();
             } else {
                 pauseGame();
                 if (!pauseMenuInitialized) { // <<< ADDED: Initialize elements on first pause
                     initializePauseMenuElements();
                     pauseMenuInitialized = true;
                 }
             }
         }

        // --- Text Wrapping Helper ---
        function wrapText(context, text, x, y, maxWidth, lineHeight) {
            const words = text.split(' ');
            let line = '';
            let currentY = y; // Start drawing at the provided y
            const originalBaseline = context.textBaseline; // Store original baseline
            context.textBaseline = 'top'; // Use 'top' for predictable line spacing

            for(let n = 0; n < words.length; n++) {
                let testLine = line + words[n] + ' ';
                let metrics = context.measureText(testLine);
                let testWidth = metrics.width;
                if (testWidth > maxWidth && n > 0) {
                    // Draw the current line (without the new word) centered
                    context.fillText(line.trim(), x, currentY);
                    line = words[n] + ' '; // Start new line with the current word
                    currentY += lineHeight; // Move Y down for the next line
                } else {
                    line = testLine; // Add word to the current line
                }
            }
            // Draw the last line centered
            context.fillText(line.trim(), x, currentY);

            context.textBaseline = originalBaseline; // Restore original baseline
        }


        // ===========================================
        // MATRIX BACKGROUND CODE (Stable)
        // ===========================================
        class MATRIX_Character { constructor(x, y, s, f, v, h = false) { this.x = x; this.y = y; this.speed = s; this.fontSize = f; this.value = v || MATRIX_getRandomChar(); this.isHead = h; this.alpha = h ? 1.0 : (0.3 + Math.random() * 0.5); this.hue = MATRIX_MAIN_COLOR_HUE; this.lightness = h ? 65 : MATRIX_TRAIL_MIN_LIGHTNESS + Math.random() * (MATRIX_TRAIL_MAX_LIGHTNESS - MATRIX_TRAIL_MIN_LIGHTNESS); } update() { this.y += this.speed; if (!this.isHead) this.alpha = Math.max(0.01, this.alpha - 0.01); } draw(ctx) { if (!ctx || this.alpha < 0.05 || isNaN(this.x) || isNaN(this.y)) return; const color = `hsla(${this.hue}, 85%, ${this.lightness}%, ${this.alpha})`; try { ctx.fillStyle = color; ctx.font = `${this.fontSize}px monospace`; ctx.fillText(this.value, this.x, this.y); } catch (e) {} if (!this.isHead && Math.random() < 0.015) this.value = MATRIX_getRandomChar(); } }
        class MATRIX_Stream { constructor(x,h){this.x=x;this.h=h;this.chars=[];this.fS=~~(Math.random()*(MATRIX_MAX_FONT_SIZE-MATRIX_MIN_FONT_SIZE+1))+MATRIX_MIN_FONT_SIZE;this.sp=MATRIX_BASE_SPEED+Math.random()*MATRIX_SPEED_VARIATION;let iY=-this.fS*~~(Math.random()*30+15);this.chars.push(new MATRIX_Character(this.x,iY,this.sp,this.fS,null,true));} spawn(){if(!this.chars.length){this.chars.push(new MATRIX_Character(this.x,0,this.sp,this.fS,null,true));return}const hC=this.chars[this.chars.length-1];if(!hC)return;const t=this.fS*(1.0+Math.random()*0.5);if(hC.y>t){try{const nC=new MATRIX_Character(this.x,0,this.sp,this.fS,null,true);hC.isHead=false;this.chars.push(nC);}catch(e){}}} updateDraw(ctx){let a=false;for(let i=this.chars.length-1;i>=0;i--){const c=this.chars[i];if(!c){this.chars.splice(i,1);continue}try{c.update();if(c.y>-this.fS*5&&c.y<this.h+this.fS*5){c.draw(ctx);a=true}if(c.y>this.h+this.fS*30||(c.y>this.h&&c.alpha<0.01)){this.chars.splice(i,1)}else{a=true}}catch(e){this.chars.splice(i,1)}}this.spawn();return this.chars.length===0&&!a;}}
        function MATRIX_setupStreams() { matrixStreams={};const a=(MATRIX_MIN_FONT_SIZE+MATRIX_MAX_FONT_SIZE)/2;const p=a*MATRIX_COLUMN_WIDTH_MULTIPLIER;const n=p>0?Math.ceil(width/p):0;for(let i=0;i<n;i++){const k=i.toString();const x=i*p+(Math.random()*p*0.5-p*0.25);if(!isNaN(x)){try{matrixStreams[k]=new MATRIX_Stream(x,height);}catch(e){}}}}
        function MATRIX_drawGlobalRain(ctx) { if(!ctx||!width||!height)return;let d=[];const a=(MATRIX_MIN_FONT_SIZE+MATRIX_MAX_FONT_SIZE)/2;const p=a*MATRIX_COLUMN_WIDTH_MULTIPLIER;const n=p>0?Math.ceil(width/p):0;for(const k in matrixStreams){if(!Object.prototype.hasOwnProperty.call(matrixStreams,k))continue;const s=matrixStreams[k];if(s){try{if(s.updateDraw(ctx))d.push(k);}catch(e){console.error("Stream err:",e);d.push(k);}}else{d.push(k);}}d.forEach(key=>delete matrixStreams[key]);for(let i=0;i<n;i++){const k=i.toString();if(!matrixStreams[k]&&Math.random()<MATRIX_FIXED_SPAWN_CHANCE){const x=i*p+(Math.random()*p*0.5-p*0.25);if(!isNaN(x)){try{matrixStreams[k]=new MATRIX_Stream(x,height);}catch(e){}}}}}

        // ===========================================
        // TETRIS GAME LOGIC (Stable)
        // ===========================================
        function createBoard() { board = Array.from({ length: boardHeight }, () => Array(boardWidth).fill(0)); }
        function getRandomPiece() { const i = Math.floor(Math.random() * PIECES.length); return { shape: PIECES[i], colorIndex: i }; }
        function spawnPiece() { currentPiece = nextPiece || getRandomPiece(); nextPiece = getRandomPiece(); currentCol = Math.floor(boardWidth / 2) - Math.floor(currentPiece.shape[0].length / 2); currentRow = 0; canSwap = true; isLockDelayActive = false; lockDelayStartTime = 0;
            // <<< DEBUG LOGGING ADDED >>>
            console.log("spawnPiece: Checking validity for:", { shape: currentPiece.shape, currentRow, currentCol });
            if (!isValidMove(currentPiece.shape, currentRow, currentCol)) {
                // --- DETAILED LOGGING FOR SPAWN FAILURE ---
                console.error("!!! GAME OVER ON SPAWN !!! - isValidMove returned false.");
                console.log("   Piece Shape:", currentPiece.shape);
                console.log(`   Spawn Position: row=${currentRow}, col=${currentCol}`);
                console.log("   Checking board state at spawn location:");
                for (let y = 0; y < currentPiece.shape.length; y++) {
                    let rowStr = `      Shape Row ${y}: `;
                    for (let x = 0; x < currentPiece.shape[y].length; x++) {
                        if (currentPiece.shape[y][x]) {
                            let bR = currentRow + y;
                            let bC = currentCol + x;
                            let boardValue = 'OOB'; // Out Of Bounds
                            if (bR >= 0 && bR < boardHeight && bC >= 0 && bC < boardWidth) {
                                boardValue = board[bR][bC];
                            }
                            rowStr += `[x=${x} -> bR=${bR},bC=${bC}, val=${boardValue}] `;
                        }
                    }
                    console.log(rowStr);
                }
                // --- END DETAILED LOGGING ---

                gameOver = true; isPaused = true;
                saveHighScoreToFirestore(); // Keep this call
                SOUNDS.GAME_OVER();
                // Show save score button
                showGameOverScreen(); // <<< Call new function
                // <<< DEBUG LOGGING ADDED >>>
                // console.error(`!!! GAME OVER ON SPAWN !!!`, { shape: currentPiece.shape, currentRow, currentCol }); // Replaced by detailed log above
            } else { lastDropTime = performance.now(); } }
        function rotateMatrix(matrix) { const r=matrix.length,c=matrix[0].length;const n=Array.from({length:c},()=>Array(r).fill(0));for(let y=0;y<r;y++){for(let x=0;x<c;x++){if(matrix[y][x])n[x][r-1-y]=1;}}return n; }
        function rotatePiece() { if (!currentPiece || isPaused || gameOver) return; const oS = currentPiece.shape; const rS = rotateMatrix(oS); const kicks = [0, -1, 1, -2, 2]; for (const k of kicks) { if (isValidMove(rS, currentRow, currentCol + k)) { const oL = isLockDelayActive; currentPiece.shape = rS; currentCol += k; SOUNDS.ROTATE(); if (oL && isValidMove(currentPiece.shape, currentRow + 1, currentCol)) { isLockDelayActive = false; } return; } } }
        function isValidMove(shape, r, c) {
            for(let y=0; y<shape.length; y++) {
                for(let x=0; x<shape[y].length; x++) {
                    if(shape[y][x]) {
                        let bR = r + y;
                        let bC = c + x;
                        // <<< DEBUG LOGGING ADDED >>>
                        // console.log('isValidMove check:', { r, c, shapeY: y, shapeX: x, bR, bC, boardVal: (bR >= 0 && bR < boardHeight && bC >= 0 && bC < boardWidth) ? board[bR][bC] : 'OutOfBounds' });
                        if (bR < 0 || bR >= boardHeight || bC < 0 || bC >= boardWidth || (bR >= 0 && board[bR][bC] !== 0)) {
                            // <<< SIMPLER DEBUG LOGGING ADDED >>>
                            console.warn(`isValidMove fail check: bR=${bR}, bC=${bC}, boardH=${boardHeight}, boardW=${boardWidth}, boardVal=${(bR >= 0 && bR < boardHeight && bC >= 0 && bC < boardWidth) ? board[bR][bC] : 'OOB'}`);
                            // <<< END DEBUG LOGGING >>>
                            return false; // Invalid move
                        }
                    }
                }
            }
            return true;
        }
        function movePiece(dX, dY) { if (!currentPiece || isPaused || gameOver) return { moved: false, needsLock: false }; if (dY > 0 && isLockDelayActive) return { moved: false, needsLock: true }; if (isValidMove(currentPiece.shape, currentRow + dY, currentCol + dX)) { const oL = isLockDelayActive; currentCol += dX; currentRow += dY; if (dY > 0) { isLockDelayActive = false; } else if (dX !== 0 && oL && isValidMove(currentPiece.shape, currentRow + 1, currentCol)) { isLockDelayActive = false; } const nL = dY > 0 && !isValidMove(currentPiece.shape, currentRow + 1, currentCol); return { moved: true, needsLock: nL }; } if (dY > 0 && !isValidMove(currentPiece.shape, currentRow + 1, currentCol)) { if (!isLockDelayActive) { return { moved: false, needsLock: true }; } } return { moved: false, needsLock: false }; }
        function hardDrop() {
            if (!currentPiece || isPaused || gameOver) return; // <<< ADDED gameOver CHECK HERE

            if (isLockDelayActive) {
                lockPiece();
                return;
            }
            const gR = calculateGhostPosition();
            if (gR > currentRow) {
                SOUNDS.HARD_DROP();
                currentRow = gR;
                if (!isValidMove(currentPiece.shape, currentRow + 1, currentCol)) {
                    if (!isLockDelayActive) {
                        isLockDelayActive = true;
                        lockDelayStartTime = performance.now();
                    }
                } else {
                    lockPiece();
                }
            } else {
                if (!isValidMove(currentPiece.shape, currentRow + 1, currentCol)) {
                    if (!isLockDelayActive) {
                        isLockDelayActive = true;
                        lockDelayStartTime = performance.now();
                    } else {
                        lockPiece();
                    }
                } else {
                    lockPiece();
                }
            }
        }
        function softDrop() { if (!currentPiece || isPaused || gameOver || isLockDelayActive) return false; const mR = movePiece(0, 1); if (mR.moved) { SOUNDS.SOFT_DROP(); lastDropTime = performance.now(); score += 1; return true; } else if (mR.needsLock) { isLockDelayActive = true; lockDelayStartTime = performance.now(); return false; } return false; }
        function lockPiece() {
            if(!currentPiece || isPaused || gameOver) return;
            isLockDelayActive = false;
            lockDelayStartTime = 0;

            // --- Check for immediate Game Over BEFORE writing piece --- 
            let isGameOverCondition = false;
            for (let y = 0; y < currentPiece.shape.length; y++) {
                for (let x = 0; x < currentPiece.shape[y].length; x++) {
                    if (currentPiece.shape[y][x]) {
                        let bR = currentRow + y;
                        if (bR < 0) { // Piece locked entirely or partially above the board
                            isGameOverCondition = true;
                            break;
                        }
                    }
                }
                if (isGameOverCondition) break;
            }

            if (isGameOverCondition) {
                isPaused = true;
                gameOver = true; // Set gameOver state here
                saveHighScoreToFirestore();
                SOUNDS.GAME_OVER();
                console.error("GAME OVER (Piece locked above board)");
                currentPiece = null; // Prevent further actions with this piece
                showGameOverScreen();
                return; // Exit function immediately
            }
            // --- End Game Over Check ---

            let pieceLanded = false;
            for(let y=0; y<currentPiece.shape.length; y++) {
                for(let x=0; x<currentPiece.shape[y].length; x++) {
                    if(currentPiece.shape[y][x]) {
                        let bR = currentRow + y;
                        let bC = currentCol + x;
                        // We already checked bR < 0 above, but keep other boundary checks
                        if (bC >= 0 && bC < boardWidth && bR >= 0 && bR < boardHeight) {
                            board[bR][bC] = currentPiece.colorIndex + 1;
                            pieceLanded = true;
                        } // else: Part of the piece is outside side/bottom bounds - ignore it
                    }
                }
            }

            if (pieceLanded) {
                SOUNDS.LAND();
                clearLines();
            } else {
                // This case might happen if a piece somehow locks entirely outside the board bounds
                // without triggering the game over check above (should be rare/impossible now)
                console.warn("lockPiece called but no blocks landed within bounds?");
            }
            spawnPiece(); // Spawn next piece only if game didn't end
        }
        function clearLines() { let cl = 0; let rTC = []; for (let r = boardHeight - 1; r >= 0; r--) { if (board[r].every(c => c !== 0)) { cl++; rTC.push(r); } } rTC.sort((a, b) => a - b); for (let i = rTC.length - 1; i >= 0; i--) { board.splice(rTC[i], 1); } for (let i = 0; i < cl; i++) { board.unshift(Array(boardWidth).fill(0)); } if (cl > 0) { score += cl * 100 * cl; totalLinesCleared += cl; if (cl === 4) { SOUNDS.TETRIS_CLEAR(); tetrisFlashEndTime = performance.now() + TETRIS_FLASH_DURATION; } else { SOUNDS.LINE_CLEAR(); flashEndTime = performance.now() + FLASH_DURATION; } while (totalLinesCleared >= nextSpeedUpMilestone) { dropInterval = Math.max(minDropInterval, dropInterval * SPEED_UP_MULTIPLIER); nextSpeedUpMilestone += LINES_PER_SPEED_INCREASE; console.log(`--- SPEED UP! Interval: ${dropInterval.toFixed(0)}ms. Next at ${nextSpeedUpMilestone} lines ---`); speedUpFlashEndTime = performance.now() + SPEED_UP_FLASH_DURATION; } } return cl; }
        function calculateGhostPosition() { if(!currentPiece||gameOver)return currentRow;let gR=currentRow;while(isValidMove(currentPiece.shape,gR+1,currentCol))gR++;return gR;}
        function swapPiece() { if (isPaused || gameOver || !canSwap) return; SOUNDS.HOLD_SWAP(); isLockDelayActive = false; if (heldPiece === null) { heldPiece = currentPiece; spawnPiece(); } else { let temp = currentPiece; currentPiece = heldPiece; heldPiece = temp; currentCol = Math.floor(boardWidth / 2) - Math.floor(currentPiece.shape[0].length / 2); currentRow = 0; if (!isValidMove(currentPiece.shape, currentRow, currentCol)) { gameOver = true; isPaused = true; saveHighScoreToFirestore(); SOUNDS.GAME_OVER(); console.log("GAME OVER (Swap)"); currentPiece = null; showGameOverScreen(); // <<< Call new function
        } } canSwap = false; }

        // ===========================================
        // DRAWING FUNCTIONS
        // ===========================================
        function drawBlock(r, c, ci, g = false, t = performance.now(), isMini = false, miniBlockSize = blockSize) { const size = isMini ? miniBlockSize : blockSize; if (size <= 0) return; let a = g ? settings_ghostAlpha : BLOCK_BASE_ALPHA; let fC; const sF = Math.sin(t * BLOCK_SHIMMER_SPEED + r + c * 0.5) * BLOCK_SHIMMER_AMOUNT; const cA = Math.max(g ? settings_ghostAlpha : 0.05, Math.min(1.0, a + (g ? 0 : sF))); if (g) { fC = `rgba(120, 255, 120, ${settings_ghostAlpha})`; } else { const [h, s, l] = BASE_COLORS_HSL[ci]; fC = `hsla(${h}, ${s}%, ${l}%, ${cA})`; } let sFl = false; if (!g && !isMini && Math.random() < BLOCK_FLICKER_CHANCE) { fC = BLOCK_FLICKER_COLOR; sFl = true; } ctx.fillStyle = fC; const x = (isMini ? 0 : boardXOffset) + c * size; const y = (isMini ? 0 : boardYOffset) + r * size; if (settings_useWireframeBlocks && !g && !isMini) { ctx.strokeStyle = fC; ctx.lineWidth = 1.5; ctx.strokeRect(x + ctx.lineWidth / 2, y + ctx.lineWidth / 2, size - ctx.lineWidth, size - ctx.lineWidth); } else { ctx.fillRect(x, y, size, size); } if (!isMini && !settings_useWireframeBlocks) { ctx.strokeStyle = sFl ? 'rgba(100, 255, 100, 0.5)' : (g ? `rgba(200, 255, 200, ${settings_ghostAlpha * 3.5})` : `rgba(0, 0, 0, ${cA * 0.6})`); ctx.lineWidth = g ? 0.5 : 1; ctx.strokeRect(x + (g ? 0.25 : 0), y + (g ? 0.25 : 0), size - (g ? 0.5 : 0), size - (g ? 0.5 : 0)); } else if (isMini) { ctx.strokeStyle = `rgba(200, 255, 200, ${cA * 0.3})`; ctx.lineWidth = 0.5; ctx.strokeRect(x+0.5, y+0.5, size-1, size-1); } }
        function drawBoard(timestamp){if(blockSize<=0)return;for(let r=0;r<boardHeight;r++){for(let c=0;c<boardWidth;c++){if(board[r][c]!==0)drawBlock(r,c,board[r][c]-1,false,timestamp);}}ctx.strokeStyle=`hsla(120,50%,20%,${BLOCK_BASE_ALPHA})`;ctx.lineWidth=2;ctx.strokeRect(boardXOffset,boardYOffset,boardWidth*blockSize,boardHeight*blockSize);}
        function drawPiece(shape, r, c, ci, g = false, t){if(blockSize<=0)return;for(let y=0;y<shape.length;y++){for(let x=0;x<shape[y].length;x++){if(shape[y][x])drawBlock(r+y,c+x,ci,g,t);}}}
        function drawMiniPiece(piece, boxRect, timestamp) { if (!piece || !ctx || boxRect.width <= 0 || boxRect.height <= 0) return; const sh = piece.shape; const ci = piece.colorIndex; const pH = sh.length; const pW = pH > 0 ? sh[0].length : 0; if(pW === 0) return; const mD = Math.max(pW, pH); const aW = boxRect.width * MINI_PIECE_SCALE; const aH = boxRect.height * MINI_PIECE_SCALE; const mBS = Math.max(1, Math.floor(Math.min(aW / mD, aH / mD))); if (mBS <= 1) return; const tPW = pW * mBS; const tPH = pH * mBS; const sX = boxRect.x + (boxRect.width - tPW) / 2; const sY = boxRect.y + (boxRect.height - tPH) / 2; ctx.save(); ctx.translate(sX, sY); for (let y = 0; y < pH; y++) { for (let x = 0; x < pW; x++) { if (sh[y][x]) { drawBlock(y, x, ci, false, timestamp, true, mBS); } } } ctx.restore(); }
        function drawInfoBoxes(timestamp) { if (!ctx || blockSize <= 0 || holdBoxRect.width <= 0 || nextBoxRect.width <= 0) return; const bC = `rgba(0, 40, 0, ${INFO_BOX_ALPHA})`; const brC = `hsla(120, 70%, 50%, ${INFO_BOX_BORDER_ALPHA})`; const lC = `hsla(120, 80%, 70%, ${INFO_BOX_LABEL_ALPHA})`; const lF = `${Math.max(10, Math.floor(blockSize * 0.5))}px monospace`; ctx.font = lF; ctx.textAlign = 'center'; ctx.textBaseline = 'top'; ctx.fillStyle = bC; ctx.fillRect(nextBoxRect.x, nextBoxRect.y, nextBoxRect.width, nextBoxRect.height); ctx.strokeStyle = brC; ctx.lineWidth = 1; ctx.strokeRect(nextBoxRect.x, nextBoxRect.y, nextBoxRect.width, nextBoxRect.height); ctx.fillStyle = lC; ctx.fillText("Next", nextBoxRect.x + nextBoxRect.width / 2, nextBoxRect.y + 3); if (nextPiece) { drawMiniPiece(nextPiece, nextBoxRect, timestamp); } ctx.fillStyle = bC; ctx.fillRect(holdBoxRect.x, holdBoxRect.y, holdBoxRect.width, holdBoxRect.height); ctx.strokeStyle = brC; ctx.strokeRect(holdBoxRect.x, holdBoxRect.y, holdBoxRect.width, holdBoxRect.height); ctx.fillStyle = lC; ctx.fillText("Hold", holdBoxRect.x + holdBoxRect.width / 2, holdBoxRect.y + 3); if (heldPiece) { drawMiniPiece(heldPiece, holdBoxRect, timestamp); } if (!canSwap) { ctx.fillStyle = 'rgba(100, 0, 0, 0.4)'; ctx.fillRect(holdBoxRect.x, holdBoxRect.y, holdBoxRect.width, holdBoxRect.height); } ctx.textAlign = 'left'; ctx.textBaseline = 'alphabetic'; }
        function drawGame(timestamp){ if (!ctx || blockSize <= 0) return; ctx.fillStyle = `rgba(0, 0, 0, ${settings_boardBackgroundAlpha})`; ctx.fillRect(boardXOffset, boardYOffset, boardWidth * blockSize, boardHeight * blockSize); drawBoard(timestamp); if (currentPiece && !gameOver) { const gR = calculateGhostPosition(); if (gR > currentRow) { drawPiece(currentPiece.shape, gR, currentCol, currentPiece.colorIndex, true, timestamp); } drawPiece(currentPiece.shape, currentRow, currentCol, currentPiece.colorIndex, false, timestamp); } }
        function drawScoreAndLines() { if (!ctx || !width || !height) return; const dF = `bold ${SCORE_LINES_FONT_SIZE}px monospace`; ctx.font = dF; let sS = `${SCORE_LABEL} ${score.toString().padStart(6,'0')}`; let lS = `${LINES_LABEL} ${totalLinesCleared.toString().padStart(3,'0')}`; let dSS = sS; let dLS = lS; let dC = SCORE_COLOR_BASE; let oX = 0, oY = 0; if (Math.random() < SCORE_GLITCH_CHANCE) { dSS = glitchText(sS, SCORE_GLITCH_INTENSITY); dLS = glitchText(lS, SCORE_GLITCH_INTENSITY); dC = SCORE_COLOR_GLITCH; oX = (Math.random() - 0.5) * SCORE_GLITCH_OFFSET * 2; oY = (Math.random() - 0.5) * SCORE_GLITCH_OFFSET * 2; } const sM = ctx.measureText(dSS); const lM = ctx.measureText(dLS); const tTW = sM.width + SCORE_LINES_GAP + lM.width; const tH = SCORE_LINES_FONT_SIZE; const bW = tTW + SCORE_LINES_BG_PADDING_X * 2; const bH = tH + SCORE_LINES_BG_PADDING_Y * 2; const bX = width / 2 - bW / 2; const bY = height - bH - SCORE_LINES_Y_MARGIN; const drY = bY + SCORE_LINES_BG_PADDING_Y + oY; ctx.fillStyle = `rgba(0, 0, 0, ${SCORE_LINES_BG_OPACITY})`; ctx.fillRect(bX, bY, bW, bH); ctx.strokeStyle = 'rgba(100, 255, 100, 0.3)'; ctx.lineWidth = 0.5; ctx.strokeRect(bX, bY, bW, bH); ctx.font = dF; ctx.fillStyle = dC; ctx.textBaseline = 'top'; const scX = bX + SCORE_LINES_BG_PADDING_X + oX; ctx.textAlign = 'left'; try { ctx.fillText(dSS, scX, drY); } catch(e) {} const liX = bX + bW - SCORE_LINES_BG_PADDING_X + oX; ctx.textAlign = 'right'; try { ctx.fillText(dLS, liX, drY); } catch(e) {} ctx.textAlign = 'left'; ctx.textBaseline = 'alphabetic'; }
        function drawTitle() { if (!ctx || !width || !height) return; const fS = Math.floor(height * TITLE_FONT_SIZE_RATIO); ctx.font = `bold ${fS}px monospace`; ctx.fillStyle = TITLE_COLOR; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; const tX = width / 2 + (Math.random() - 0.5) * 4; const tY = height / 2 + (Math.random() - 0.5) * 4; let tTD = TITLE_TEXT; if (Math.random() < 0.03) { tTD = glitchText(TITLE_TEXT, 0.2, ['#', '*', '!', '?']); } ctx.fillText(tTD, tX, tY); ctx.textAlign = 'left'; ctx.textBaseline = 'alphabetic'; }
        function drawSettingsIcon() {
            if (!ctx || isPaused || gameOver) return;

            const x = settingsButtonRect.x;
            const y = settingsButtonRect.y;
            const s = settingsButtonRect.width; // Size (width/height)
            const cx = x + s / 2; // Center X
            const cy = y + s / 2; // Center Y

            const numTeeth = 6;
            const innerRadius = s * 0.2;  // Radius of the central hole
            const outerRadius = s * 0.4;  // Radius to the base of the teeth
            const toothTipRadius = s * 0.48; // Radius to the tip of the teeth
            const toothWidthAngle = Math.PI / numTeeth * 0.6; // Angular width of each tooth

            // Style
            ctx.fillStyle = 'rgba(50, 150, 50, 0.7)'; // Slightly more opaque fill
            ctx.strokeStyle = 'rgba(150, 255, 150, 0.8)'; // Slightly more opaque stroke
            ctx.lineWidth = 1.5; // Slightly thinner line

            ctx.beginPath();

            // Draw Teeth
            for (let i = 0; i < numTeeth; i++) {
                const angle = (i / numTeeth) * Math.PI * 2;

                // Point 1: Inner corner of tooth base (clockwise)
                let currentAngle = angle - toothWidthAngle / 2;
                ctx.lineTo(cx + Math.cos(currentAngle) * outerRadius, cy + Math.sin(currentAngle) * outerRadius);

                // Point 2: Outer corner of tooth tip (clockwise)
                ctx.lineTo(cx + Math.cos(currentAngle) * toothTipRadius, cy + Math.sin(currentAngle) * toothTipRadius);

                // Point 3: Outer corner of tooth tip (counter-clockwise)
                currentAngle = angle + toothWidthAngle / 2;
                ctx.lineTo(cx + Math.cos(currentAngle) * toothTipRadius, cy + Math.sin(currentAngle) * toothTipRadius);

                // Point 4: Inner corner of tooth base (counter-clockwise)
                ctx.lineTo(cx + Math.cos(currentAngle) * outerRadius, cy + Math.sin(currentAngle) * outerRadius);
            }
            ctx.closePath(); // Close the outer path (teeth)
            ctx.fill();
            ctx.stroke();

            // Draw Central Hole
            ctx.beginPath();
            ctx.arc(cx, cy, innerRadius, 0, Math.PI * 2);
            // Cut out the hole - need to change composite operation
            ctx.save(); // Save current state
            ctx.clip(); // Clip to the hole path
            ctx.clearRect(x, y, s, s); // Clear the area inside the hole (important)
            // Alternatively, fill with background color if clearRect isn't cutting through existing fill
            // ctx.fillStyle = 'black'; // Or your background color
            // ctx.fill();
            ctx.restore(); // Restore state (removes clipping path)

             // Stroke the central hole border separately
             ctx.beginPath();
             ctx.arc(cx, cy, innerRadius, 0, Math.PI * 2);
             ctx.stroke();
        }

        // ===========================================
        // Game Loop (Stable)
        // ===========================================
        let gameStartTime = 0; let lastFrameTime = 0; const MAX_FPS = 60; const MIN_FRAME_TIME = 1000 / MAX_FPS;
        function gameLoop(timestamp) { requestAnimationFrame(gameLoop); const elapsed = timestamp - lastFrameTime; lastFrameTime = timestamp; const now = performance.now(); if (!isPaused && !gameOver) { if (currentPiece) { if (isLockDelayActive) { if (now - lockDelayStartTime > LOCK_DELAY_DURATION) { lockPiece(); } } else if (now - lastDropTime > dropInterval) { const mR = movePiece(0, 1); if (mR.needsLock) { isLockDelayActive = true; lockDelayStartTime = now; } else if (mR.moved) { lastDropTime = now; } else { lastDropTime = now; } } } } else if (isPaused && !gameOver && gameStartTime === 0) { updatePromptGlitches(); }
            ctx.fillStyle = `rgba(0, 0, 0, ${MATRIX_GLOBAL_FADE_FACTOR})`; ctx.fillRect(0, 0, width, height); MATRIX_drawGlobalRain(ctx); drawTitle();
            // Updated game loop: Don't draw game if gameOver
            if (gameOver) {
                // Game over screen is now an HTML overlay, no drawing needed here
                if (promptElement.style.display !== 'none') { promptElement.style.display = 'none'; resetPromptGlitches(); }
            }
            else if (isPaused) { if (gameStartTime === 0) { if (promptElement.style.display === 'none') promptElement.style.display = 'block'; } else { drawGame(timestamp); drawInfoBoxes(timestamp); drawScoreAndLines(); drawPauseMenu(); if (promptElement.style.display !== 'none') { promptElement.style.display = 'none'; resetPromptGlitches(); } } }
            else { drawGame(timestamp); drawInfoBoxes(timestamp); drawScoreAndLines(); drawSettingsIcon(); if (promptElement.style.display !== 'none') { promptElement.style.display = 'none'; resetPromptGlitches(); } }
            if (now < flashEndTime) { ctx.fillStyle = FLASH_COLOR; ctx.fillRect(0, 0, width, height); } if (now < speedUpFlashEndTime) { ctx.fillStyle = SPEED_UP_FLASH_COLOR; ctx.fillRect(0, 0, width, height); } if (now < tetrisFlashEndTime) { ctx.fillStyle = TETRIS_FLASH_COLOR; ctx.fillRect(0, 0, width, height); }
        }

        // ===========================================
        // Setup & Sizing
        // ===========================================
        function calculateSizes() { const bUISpace = SCORE_LINES_FONT_SIZE + SCORE_LINES_BG_PADDING_Y * 2 + SCORE_LINES_Y_MARGIN + 10; const bBtnSpace = SETTINGS_ICON_SIZE + SETTINGS_ICON_MARGIN + 5; const resBotSpace = Math.max(bUISpace, bBtnSpace); const tMBoard = boardYOffset + 10; const bFH = (height - tMBoard - resBotSpace) / boardHeight; const bFW = width / boardWidth; blockSize = Math.max(5, Math.floor(Math.min(bFH, bFW)) - 1); const tBW = boardWidth * blockSize; const tBH = boardHeight * blockSize; boardXOffset = Math.floor((width - tBW) / 2); const eBY = boardYOffset; const boxS = Math.max(16, Math.floor(blockSize * 3)); const fBW = boxS; const fBH = boxS; nextBoxRect = { x: boardXOffset + INFO_BOX_MARGIN, y: eBY + INFO_BOX_MARGIN, width: fBW, height: fBH }; holdBoxRect = { x: boardXOffset + tBW - fBW - INFO_BOX_MARGIN, y: eBY + INFO_BOX_MARGIN, width: fBW, height: fBH }; settingsButtonRect = { x: SETTINGS_ICON_MARGIN, y: height - SETTINGS_ICON_SIZE - SETTINGS_ICON_MARGIN, width: SETTINGS_ICON_SIZE, height: SETTINGS_ICON_SIZE }; pauseMenuCloseButtonRect = { x: width - PAUSE_MENU_CLOSE_BUTTON_SIZE - PAUSE_MENU_CLOSE_BUTTON_MARGIN, y: PAUSE_MENU_CLOSE_BUTTON_MARGIN, width: PAUSE_MENU_CLOSE_BUTTON_SIZE, height: PAUSE_MENU_CLOSE_BUTTON_SIZE }; }
        function setup(isInitialSetup = false) {
            console.log("--- Running Setup ---", "isInitial:", isInitialSetup);
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            if (isInitialSetup) {
                loadSettings(); // This now initializes Firebase and attempts to load high score
            }
            calculateSizes();
            MATRIX_setupStreams();
            createBoard();
            score = 0;
            totalLinesCleared = 0;
            gameOver = false;
            dropInterval = initialDropInterval;
            nextSpeedUpMilestone = LINES_PER_SPEED_INCREASE;
            flashEndTime = 0; speedUpFlashEndTime = 0; tetrisFlashEndTime = 0;
            isLockDelayActive = false; lockDelayStartTime = 0;
            currentPiece = null;
            nextPiece = getRandomPiece();
            heldPiece = null;
            canSwap = true;
            if (isInitialSetup) {
                isPaused = true;
                gameStartTime = 0;
                lastFrameTime = 0;
                promptInstructionsText.innerHTML = ORIGINAL_PROMPT_INSTRUCTIONS;
                promptElement.style.display = 'block';
                resetPromptGlitches();
                highScoreDisplayElement.style.display = 'block'; // Show high score initially
                gameOverOverlay.style.display = 'none'; // Ensure overlay is hidden
                console.log("Setup Initial: state set.", {isPaused, gameOver, gameStartTime});
            } else {
                console.log("Setup Start Game: ...");
                try {
                    playStartupSequence();
                    isPaused = false;
                    spawnPiece();
                    if (!gameOver) {
                        gameStartTime = performance.now();
                        lastDropTime = gameStartTime;
                        lastFrameTime = gameStartTime;
                        // Ensure high score is loaded if Firebase init was delayed
                        if (!db) {
                            loadSettings(); // Attempt re-init/load if needed
                        } else {
                            // If DB already exists, ensure score is loaded (might be redundant but safe)
                            loadHighScoreFromFirestore();
                        }
                    } else {
                        isPaused = true;
                    }
                    promptElement.style.display = 'none';
                    resetPromptGlitches();
                    highScoreDisplayElement.style.display = 'block'; // Show high score during game
                    gameOverOverlay.style.display = 'none'; // Ensure overlay is hidden
                    console.log("Setup Start Game: state set.", {isPaused, gameOver, gameStartTime});
                } catch (error) {
                    console.error("!!!! ERROR DURING setup(false) !!!!", error);
                    isPaused = true; gameOver = true; ctx.fillStyle = 'red'; ctx.font = '20px monospace'; ctx.textAlign = 'center'; ctx.fillText("ERROR DURING STARTUP", width/2, height/2); ctx.textAlign = 'left'; if (promptElement) promptElement.style.display = 'none';
                    showGameOverScreen(); // Show overlay even on startup error
                }
            }
            console.log(`--- Setup Complete W:${width} H:${height} ---`);
        }

        // ===========================================
        // Fullscreen & Start
        // ===========================================
        function requestAppFullscreen() { const e=document.documentElement;if(e.requestFullscreen)return e.requestFullscreen();else if(e.webkitRequestFullscreen)return e.webkitRequestFullscreen();else if(e.msRequestFullscreen)return e.msRequestFullscreen();else return Promise.resolve(); }
        function exitAppFullscreen() { if(document.exitFullscreen) return document.exitFullscreen(); else if(document.webkitExitFullscreen) return document.webkitExitFullscreen(); else if(document.msExitFullscreen) return document.msExitFullscreen(); else return Promise.resolve();}
        function toggleFullscreen() { if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.msFullscreenElement) { requestAppFullscreen().catch(err => console.error(`FS request failed: ${err.message}`)); } else { exitAppFullscreen().catch(err => console.error(`FS exit failed: ${err.message}`)); } }
        function handleStartInteraction() {
            if (gameStartTime === 0 && !gameOver) {
                console.log(">>> Start Interaction <<<"); initAudio(); setup(false);
            } else if (gameOver) {
                console.log(">>> Restart Interaction (from game over) <<<");
                restartGame(); // Call the new restart function
            }
        }

        // ===========================================
        // Pause Menu Interaction (Handles new slider/button)
        // ===========================================
        function handlePauseMenuInteraction(x, y, isTapEnd = false) {
            if (!isPaused || gameOver) return false;
            let interactedWithElement = false;
            const leaderboardRect = pauseMenuElements.leaderboard?.rect; // Use optional chaining

            // --- Handle Touch Scroll Drag --- 
            if (!isTapEnd && activeScrollArea === 'leaderboard') {
                const deltaY = y - touchStartY; // Use the specific touch start Y
                const leaderboardContentHeight = pauseLeaderboardData ? pauseLeaderboardData.length * (PAUSE_MENU_VALUE_FONT_SIZE * 0.9) : 0;
                const maxScroll = Math.max(0, leaderboardContentHeight - leaderboardRect.height + 10);
                // Adjust scroll based on drag delta - invert direction for natural scrolling
                pauseLeaderboardScrollY = clamp(pauseLeaderboardScrollY - deltaY * 1.5, 0, maxScroll); // Adjust multiplier for sensitivity
                touchStartY = y; // Update start Y for continuous dragging
                interactedWithElement = true;
                return true; // Prevent other interactions while scrolling
            }
            // --- End Handle Touch Scroll Drag ---

            // Handle Slider Drag
            if (!isTapEnd && activeSlider) {
                const el = pauseMenuElements[activeSlider];
                if (el && el.type === 'slider') {
                    const rX = clamp(x - el.rect.x, 0, el.rect.width); // Relative X within slider bounds
                    const ratio = rX / el.rect.width;
                    let newValue = el.min + ratio * (el.max - el.min);

                    // Update the setting based on which slider is active
                    if (el.setting === 'ghostAlpha') {
                        settings_ghostAlpha = clamp(newValue, el.min, el.max);
                    } else if (el.setting === 'boardBackgroundAlpha') {
                        settings_boardBackgroundAlpha = clamp(newValue, el.min, el.max);
                    }
                    saveSettings(); // Persist the change
                    interactedWithElement = true;
                    return true; // Prevent other interactions while dragging slider
                }
            }

            // Handle Activation of Controls (Start Scroll, Start Slider Drag, Identify Button Area)
            if (!isTapEnd && !activeSlider && activeScrollArea === null) { // Only check for new activations if not already dragging
                 // Check for starting scroll drag in leaderboard
                 if (leaderboardRect && isPointInRect(x, y, leaderboardRect)) {
                    activeScrollArea = 'leaderboard';
                    touchStartY = y; // Store initial Y for scroll calculation
                    interactedWithElement = true;
                    // Don't return yet, let slider check run too just in case of overlap
                }

                 // Check for starting slider drag
                 for (const key in pauseMenuElements) {
                     const el = pauseMenuElements[key];
                     if (!el || !el.rect || el.type !== 'slider') continue;

                     // Check if touch is near the handle or on the track
                     const handleDistSq = (x - el.handleX)**2 + (y - el.handleY)**2;
                     const handleRadiusSq = (PAUSE_MENU_SLIDER_HANDLE_SIZE * 1.5)**2; // Generous handle hit area
                     if (handleDistSq <= handleRadiusSq || isPointInRect(x, y, el.rect)) {
                        activeSlider = key; // Activate this slider
                        interactedWithElement = true;
                        // Immediately update value based on initial tap position
                        const rX = clamp(x - el.rect.x, 0, el.rect.width);
                        const ratio = rX / el.rect.width;
                        let newValue = el.min + ratio * (el.max - el.min);
                        if (el.setting === 'ghostAlpha') settings_ghostAlpha = clamp(newValue, el.min, el.max);
                        else if (el.setting === 'boardBackgroundAlpha') settings_boardBackgroundAlpha = clamp(newValue, el.min, el.max);
                        saveSettings();
                        SOUNDS.UI_CLICK(); // Play sound on initial activation
                        break; // Stop checking once a slider is activated
                    }
                 }
                 // If we started scrolling or dragging a slider, return true now
                 if (activeScrollArea || activeSlider) return true;
            }

            // Handle Button/Close Clicks on Tap End
            if (isTapEnd) {
                const wasScrolling = activeScrollArea === 'leaderboard'; // Check if we *were* scrolling
                activeScrollArea = null; // Always reset scroll area on tap end
                if (wasScrolling) {
                     // If the tap ended while scrolling, consume the event and do nothing else
                     return true;
                 }

                 // If not scrolling and not dragging a slider, check for button clicks
                if (!activeSlider) {
                    for (const key in pauseMenuElements) {
                        const el = pauseMenuElements[key];
                        if (!el || !el.rect) continue;

                        if (el.type === 'button' && isPointInRect(x, y, el.rect)) {
                            interactedWithElement = true; // <<< FIX: Set flag HERE for button clicks
                            if (el.action === 'toggleFullscreen') {
                                toggleFullscreen();
                            } else if (el.setting === 'useWireframeBlocks') {
                                settings_useWireframeBlocks = !settings_useWireframeBlocks;
                            } else if (el.setting === 'sfxEnabled') {
                                settings_sfxEnabled = !settings_sfxEnabled;
                            }
                            saveSettings();
                            SOUNDS.UI_CLICK();
                            break; // Button found and handled
                        } else if (el.type === 'closeButton' && isPointInRect(x, y, el.rect)) {
                            interactedWithElement = true; // <<< FIX: Set flag HERE for close button click
                            resumeGame();
                            return true; // Resume game immediately
                        }
                    }
                }
            }

            // Check if tap ended on background to resume game
            // <<< TEMP DEBUG: Comment out background resume logic >>>
            /*
            if (isTapEnd && !interactedWithElement && !activeSlider && activeScrollArea === null && !isPointInRect(x, y, settingsButtonRect)) { // Added activeScrollArea check
                // Make sure it wasn't a click on any pause menu element rect (redundant but safe)
                let clickedPauseElement = false;
                for (const key in pauseMenuElements) {
                    if (pauseMenuElements[key].rect && isPointInRect(x, y, pauseMenuElements[key].rect)) {
                        clickedPauseElement = true;
                        break;
                    }
                }
                if (!clickedPauseElement) {
                    resumeGame();
                    return true; // Resumed game
                }
            }
            */

            // Return true if any interaction occurred (slider drag, scroll drag, button click identified/handled)
            return interactedWithElement || !!activeSlider || activeScrollArea !== null; // Return true if scrolling or slider active
        }

        // ===========================================
        // Event Listeners (Stable)
        // ===========================================
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            initAudio();
            if (gameOver) {
                // If game over, any touch should restart (consistent with old version's mousedown/enter)
                // We use handleStartInteraction which calls restartGame() when gameOver is true.
                handleStartInteraction();
                return;
            }
            const touch = e.changedTouches[0];
            if (!touch) return;
            const tX = touch.clientX;
            const tY = touch.clientY;

            // <<< NEW: Handle Pause Menu Interaction FIRST >>>
            if (isPaused && gameStartTime > 0) {
                touchIdentifier = touch.identifier;
                // Store initial touch position for potential scroll drag
                touchStartX = tX; // Store start for scroll delta calculation
                touchStartY = tY;
                if (handlePauseMenuInteraction(tX, tY, false)) {
                    return; // Interaction handled by pause menu, stop here
                }
                // If pause menu didn't handle it, don't proceed to game logic
                return;
            }
            // <<< END NEW PAUSE HANDLING >>>

            // --- OLD/Reverted Gameplay Touch Start Logic ---
            if (!isPaused && !gameOver) { // Only run if game is active
                if (isPointInRect(tX, tY, settingsButtonRect)) {
                    togglePause(); // Allow pausing via icon tap
                    touchIdentifier = null; // Don't track this touch further
                    return;
                }
                // Start tracking touch for gameplay gestures
                touchIdentifier = touch.identifier;
                touchStartX = tX;
                touchStartY = tY;
                touchStartTime = performance.now();
                isDraggingDown = false;
                isDraggingHorizontally = false;
                lastSoftDropY = tY;
                lastHorizontalMoveX = tX;
                horizontalMoveAccumulator = 0;
            }
            // --- END OLD/Reverted Gameplay Touch Start Logic ---
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = Array.from(e.changedTouches).find(t => t.identifier === touchIdentifier);
            if (!touch) return; // Only process the tracked touch
            const cX = touch.clientX;
            const cY = touch.clientY;

            // <<< NEW: Handle Pause Menu Interaction (Slider Drag / Scroll Drag) FIRST >>>
            if (isPaused && gameStartTime > 0 && (activeSlider || activeScrollArea)) {
                 handlePauseMenuInteraction(cX, cY, false);
                 return; // Interaction handled by pause menu, stop here
             }
            // <<< END NEW PAUSE HANDLING >>>

             // --- OLD/Reverted Gameplay Touch Move Logic ---
             if (isPaused || gameOver || !currentPiece) return; // Ignore move if paused, game over, or no piece

             const tDX = cX - touchStartX; // Total delta from start
             const tDY = cY - touchStartY; // Total delta from start
             const iDX = cX - lastHorizontalMoveX; // Incremental delta X
             const iDY = cY - lastSoftDropY; // Incremental delta Y

             // Determine primary drag direction (more horizontal or vertical movement?)
             const isPrimarilyHorizontal = Math.abs(tDX) > Math.abs(tDY) * 1.2 && Math.abs(tDX) > TAP_MOVEMENT_THRESHOLD / 2;
             const isPrimarilyVertical = Math.abs(tDY) > Math.abs(tDX) * 1.2 && tDY > SOFT_DROP_START_THRESHOLD; // Only consider downward vertical drag significant

             // Horizontal Drag Logic
             if (!isDraggingDown && (isDraggingHorizontally || isPrimarilyHorizontal)) {
                 if (!isDraggingHorizontally) isDraggingHorizontally = true; // Lock to horizontal drag
                 horizontalMoveAccumulator += iDX;
                 const effectiveBlockSize = Math.max(10, blockSize); // Avoid division by zero or tiny thresholds
                 const requiredPixelsPerMove = effectiveBlockSize * HORIZONTAL_MOVE_PIXEL_THRESHOLD;

                 while (Math.abs(horizontalMoveAccumulator) >= requiredPixelsPerMove) {
                     const direction = horizontalMoveAccumulator > 0 ? 1 : -1;
                     if (movePiece(direction, 0).moved) {
                         SOUNDS.MOVE();
                         horizontalMoveAccumulator -= direction * requiredPixelsPerMove; // Consume moved distance
                     } else {
                         horizontalMoveAccumulator = 0; // Stop if move failed (hit wall)
                         break;
                     }
                 }
                 lastHorizontalMoveX = cX; // Update last position for next incremental delta
             }
             // Vertical Drag (Soft Drop) Logic
             else if (!isDraggingHorizontally && (isDraggingDown || isPrimarilyVertical)) {
                 if (!isDraggingDown) isDraggingDown = true; // Lock to vertical drag

                 if (!isLockDelayActive) { // Only allow soft drop if lock delay isn't active
                     let pixelsDraggedSinceLastDrop = iDY;
                     let blocksToDrop = Math.floor(pixelsDraggedSinceLastDrop * SOFT_DROP_MOVE_PER_PIXEL);

                     if (blocksToDrop > 0) {
                         let successfulDrops = 0;
                         for (let i = 0; i < blocksToDrop; i++) {
                             if (softDrop()) { // softDrop handles scoring and sound
                                 successfulDrops++;
                             } else {
                                 break; // Stop if soft drop fails (piece landed or needs lock)
                             }
                         }
                         // Update lastSoftDropY based on successful drops to avoid over-dropping
                         // We estimate the pixel distance covered by successful drops
                         if (successfulDrops > 0 && SOFT_DROP_MOVE_PER_PIXEL > 0) {
                              lastSoftDropY = Math.min(lastSoftDropY + successfulDrops / SOFT_DROP_MOVE_PER_PIXEL, cY);
                         }
                     }
                 }
                 // Always update lastSoftDropY to current Y if dragging down,
                 // unless we specifically adjusted it above for successful drops.
                 // This prevents large jumps if the drop rate calculation isn't perfect.
                 if (!(successfulDrops > 0)) {
                     lastSoftDropY = cY;
                 }

             } else {
                 // If not clearly dragging H or V, update both last positions
                 lastHorizontalMoveX = cX;
                 lastSoftDropY = cY;
             }
             // --- END OLD/Reverted Gameplay Touch Move Logic ---

        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            const touch = Array.from(e.changedTouches).find(t => t.identifier === touchIdentifier);

            // <<< NEW: Handle Pause Menu Interaction (Button Click / Scroll Release / Slider Release) FIRST >>>
            if (!touch) {
                // If the tracked touch isn't in changedTouches (maybe cancelled?),
                // still try to handle pause menu interaction with the first available touch end event.
                 const genericTouch = e.changedTouches[0];
                 if (isPaused && gameStartTime > 0 && genericTouch) {
                     if(handlePauseMenuInteraction(genericTouch.clientX, genericTouch.clientY, true)) {
                         activeSlider = null; // Ensure deactivation on general touch end if pause handled it
                         activeScrollArea = null;
                     }
                 }
                 activeSlider = null; // Always ensure deactivation if tracked touch wasn't found
                 activeScrollArea = null;
                 touchIdentifier = null; // Clear identifier if tracked touch ended/cancelled
                 return;
            }

            // We found the tracked touch ending
            const tEX = touch.clientX;
            const tEY = touch.clientY;
            const currentTouchId = touchIdentifier; // Store before clearing
            touchIdentifier = null; // Clear the tracked identifier

             if (isPaused && gameStartTime > 0) {
                 // Handle slider release, button click, or scroll end
                 if (handlePauseMenuInteraction(tEX, tEY, true)) {
                     activeSlider = null; // Ensure slider is deactivated
                     activeScrollArea = null; // Ensure scroll area is deactivated
                     return; // Interaction handled by pause menu, stop here
                 }
             }
             // Ensure these are reset even if pause menu didn't explicitly handle the event
             activeSlider = null;
             activeScrollArea = null;
             // <<< END NEW PAUSE HANDLING >>>


             // --- OLD/Reverted Gameplay Touch End Logic ---
             if (isPaused || gameOver) return; // Ignore if paused or game over

             // Store drag state *before* resetting flags
             const wasDraggingDown = isDraggingDown;
             const wasDraggingHorizontally = isDraggingHorizontally;

             // Reset dragging flags
             isDraggingDown = false;
             isDraggingHorizontally = false;
             horizontalMoveAccumulator = 0; // Reset accumulator

             const elapsedTime = performance.now() - touchStartTime;
             const deltaX = tEX - touchStartX;
             const deltaY = tEY - touchStartY;
             const absDeltaX = Math.abs(deltaX);
             const absDeltaY = Math.abs(deltaY);

             let actionTaken = false;

             // 1. Check for Tap (Rotate/Swap)
             if (!wasDraggingDown && !wasDraggingHorizontally && // Wasn't dragging
                 elapsedTime < TAP_TIME_LIMIT && // Within tap time
                 absDeltaX < TAP_MOVEMENT_THRESHOLD && // Minimal X movement
                 absDeltaY < TAP_MOVEMENT_THRESHOLD) { // Minimal Y movement

                 let tappedHold = (holdBoxRect.width > 0 && isPointInRect(tEX, tEY, holdBoxRect));
                 let tappedNext = (nextBoxRect.width > 0 && isPointInRect(tEX, tEY, nextBoxRect));

                 if (tappedHold) {
                     swapPiece();
                     actionTaken = true;
                 } else if (tappedNext) {
                     // Tapping 'Next' area does nothing in original logic
                     actionTaken = false; // Explicitly false, though default is false
                 } else {
                     // Tap anywhere else is rotate
                     rotatePiece();
                     actionTaken = true;
                 }
             }

             // 2. Check for Swipe (Hard Drop) - Only if not already handled by tap
             if (!actionTaken && !wasDraggingDown && !wasDraggingHorizontally && // Wasn't dragging
                 elapsedTime < SWIPE_TIME_LIMIT) { // Within swipe time

                 // Check for vertical swipe (significant Y movement, more Y than X)
                 if (absDeltaY > SWIPE_THRESHOLD && absDeltaY > absDeltaX * 1.2) {
                     // Original logic only considers downward swipe for hard drop implicitly
                     // (Upward flick wasn't standard Tetris control)
                     // Let's keep it simple: any significant vertical flick is hard drop
                     hardDrop();
                     actionTaken = true;
                 }
                 // Horizontal swipe wasn't explicitly handled in old touchend, drag logic covered movement
             }

             // 3. Handle end of Drag (Apply Lock Delay if needed)
             // If dragging occurred and no other action (tap/swipe) was taken
             if ((wasDraggingDown || wasDraggingHorizontally) && !actionTaken && currentPiece) {
                 // Check if the piece is now in a position where it should lock
                 if (!isLockDelayActive && !isValidMove(currentPiece.shape, currentRow + 1, currentCol)) {
                     isLockDelayActive = true;
                     lockDelayStartTime = performance.now();
                 }
                 actionTaken = true; // Consider drag-end finalization an action
             }
             // --- END OLD/Reverted Gameplay Touch End Logic ---

        }, { passive: false });

        canvas.addEventListener('touchcancel', (e) => {
            const touch = Array.from(e.changedTouches).find(t => t.identifier === touchIdentifier);
            if (touch) {
                 console.log("Tracked touch cancelled:", touch.identifier);
                 touchIdentifier = null; // Stop tracking
                 // Reset states associated with the touch
                 activeSlider = null;
                 activeScrollArea = null; // <<< ADDED: Reset scroll area on cancel
                 isDraggingDown = false;
                 isDraggingHorizontally = false;
                 horizontalMoveAccumulator = 0;
             } else {
                 // If a non-tracked touch cancels, we probably don't need to do anything
                 // unless it affects the pause menu state, which handlePauseMenuInteraction should manage.
             }
        }, { passive: false });

        // Changed listener from canvas to window
        window.addEventListener('keydown', (e) => {
            // Handle start/restart interaction specifically for Enter key
            if (gameOver) {
                if (e.key === 'Enter') {
                    e.preventDefault(); // Prevent default Enter behavior
                    // Check if the name input is focused
                    if (document.activeElement === playerNameInput) {
                        submitScore(); // Submit score if input is focused
                    } else {
                        handleStartInteraction(); // Otherwise, restart game
                    }
                    return; // Don't process other keys if game over + Enter
                }
            } else if (isPaused && gameStartTime === 0 && promptElement.style.display !== 'none') {
                 if (e.key === 'Enter') {
                    e.preventDefault(); // Prevent default Enter behavior
                    handleStartInteraction(); // Start the game
                    return;
                }
            }

            // Handle pause key
            // <<< FIX: Add check for e.key before using toLowerCase() >>>
            if (e.key && e.key.toLowerCase() === 'p') {
                e.preventDefault(); togglePause(); return;
            }

            // Ignore other keys if paused, game over, or no piece
            if (isPaused || gameOver || !currentPiece) return;

            // Handle in-game controls
            // <<< FIX: Add check for e.key before using toLowerCase() >>>
            const keyLower = e.key ? e.key.toLowerCase() : null;
            if (keyLower && (['arrowup', 'arrowdown', 'arrowleft', 'arrowright', ' ', 'shift', 'w', 'a', 's', 'd'].includes(keyLower) || e.code === 'Space')) {
                e.preventDefault();
                initAudio();
                switch (keyLower) { // Use the safe lowercased key
                    case 'arrowleft':
                    case 'a': // Added 'a'
                        if(movePiece(-1, 0).moved) SOUNDS.MOVE();
                        break;
                    case 'arrowright':
                    case 'd': // Added 'd'
                        if(movePiece(1, 0).moved) SOUNDS.MOVE();
                        break;
                    case 'arrowdown':
                    case 's': // Added 's'
                        softDrop();
                        break;
                    case 'arrowup':
                    case 'w': // Added 'w'
                        hardDrop();
                        break;
                    case ' ': case 'spacebar': // Keep spacebar check for robustness if needed
                        rotatePiece();
                        break;
                    case 'shift':
                        swapPiece();
                        break;
                }
            }
        });
        canvas.addEventListener('contextmenu', (e) => e.preventDefault());
        // Removed conflict markers and duplicate code for mousedown listener
        canvas.addEventListener('mousedown', (e) => { if (gameOver) { if (e.button === 0) { restartGame(); } return; } const mX = e.clientX; const mY = e.clientY; initAudio(); if (isPaused && gameStartTime > 0) { if (handlePauseMenuInteraction(mX, mY, false)) { e.preventDefault(); } return; } if (!isPaused && !gameOver) { if (isPointInRect(mX, mY, settingsButtonRect)) { togglePause(); e.preventDefault(); return; } if (e.button === 0) { let tH = (holdBoxRect.width > 0 && isPointInRect(mX, mY, holdBoxRect)); let tN = (nextBoxRect.width > 0 && isPointInRect(mX, mY, nextBoxRect)); if (tH) { swapPiece(); e.preventDefault(); } else if (!tN) { rotatePiece(); e.preventDefault(); } } else if (e.button === 2) { swapPiece(); e.preventDefault(); } } }); // <-- Added the missing closing parenthesis and semicolon
        canvas.addEventListener('mousemove', (e) => { if (isPaused && activeSlider && e.buttons === 1) { handlePauseMenuInteraction(e.clientX, e.clientY, false); e.preventDefault(); } });
        canvas.addEventListener('mouseup', (e) => { const mX = e.clientX; const mY = e.clientY; if (activeSlider) { activeSlider = null; e.preventDefault(); return; } if (isPaused && gameStartTime > 0 && e.button === 0) { if (handlePauseMenuInteraction(mX, mY, true)) { e.preventDefault(); } } });
        // <<< ADDED MOUSE WHEEL LISTENER FOR PAUSE LEADERBOARD SCROLL >>>
        canvas.addEventListener('wheel', (e) => {
            if (isPaused && gameStartTime > 0 && pauseMenuElements.leaderboard) {
                const leaderboardRect = pauseMenuElements.leaderboard.rect;
                if (isPointInRect(e.clientX, e.clientY, leaderboardRect)) {
                    e.preventDefault(); // Prevent page scroll

                    const scrollAmount = e.deltaY * 0.5; // Adjust multiplier for sensitivity
                    const leaderboardContentHeight = pauseLeaderboardData ? pauseLeaderboardData.length * (PAUSE_MENU_VALUE_FONT_SIZE * 0.9) : 0;
                    const maxScroll = Math.max(0, leaderboardContentHeight - leaderboardRect.height + 10); // +10 for padding

                    pauseLeaderboardScrollY = clamp(pauseLeaderboardScrollY + scrollAmount, 0, maxScroll);
                    // console.log(`ScrollY: ${pauseLeaderboardScrollY.toFixed(1)}, Max: ${maxScroll.toFixed(1)}`); // Optional debug log
                }
            }
        }, { passive: false }); // Need passive:false to preventDefault

        window.addEventListener('resize', () => { 
            width = window.innerWidth; 
            height = window.innerHeight; 
            canvas.width = width; 
            canvas.height = height; 
            calculateSizes(); 
            MATRIX_setupStreams(); 
            // Re-initialize pause menu elements on resize if it was already shown
            if (pauseMenuInitialized) {
                 initializePauseMenuElements();
            }
        });
        promptElement.addEventListener('click', handleStartInteraction);
        setup(true);
        // Removed requestAnimationFrame(gameLoop) call from here
        console.log(">>> Matrix Tetris Initialized (Paused - Awaiting Interaction) <<<");

        // Wait for DOMContentLoaded to ensure Firebase scripts have loaded/run
        // Moved this listener INSIDE the IIFE
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOMContentLoaded fired. Running initial setup/game loop.");
            // setup(true) is already called above, we just need to start the loop
            // We might need to re-check Firebase init status here if needed

            // Add listeners for the new Game Over overlay buttons
            if (submitScoreButton) {
                submitScoreButton.addEventListener('click', submitScore); // New save function
            } else {
                console.error("Submit score button not found!");
            }
            if (restartButton) {
                restartButton.addEventListener('click', restartGame); // New restart function
            } else {
                console.error("Restart button not found!");
            }

            // Start the game loop *once*
            requestAnimationFrame(gameLoop);
        });

        // --- New Game Over & Leaderboard Functions ---

        function showGameOverScreen() {
            console.log("Showing Game Over Overlay");
            isPaused = true; // Ensure pause state
            gameOver = true; // Ensure game over state

            // Hide in-game UI elements
            highScoreDisplayElement.style.display = 'none';
            // (Settings icon is already hidden via drawSettingsIcon logic)

            // Populate overlay stats
            gameOverScoreEl.textContent = `Score: ${score}`;
            gameOverLinesEl.textContent = `Lines: ${totalLinesCleared}`;
            gameOverHighscoreEl.textContent = `High Score: ${highScore}`; // Assumes highScore is up-to-date

            // Clear previous status message and enable input/button
            saveStatusMessage.textContent = '';
            playerNameInput.disabled = false;
            playerNameInput.value = ''; // Clear previous name
            submitScoreButton.disabled = false;
            submitScoreButton.textContent = 'Save Score';

            saveScoreSection.style.display = 'flex'; // <<< ADDED: Make save section visible

            // Load the leaderboard for the overlay
            loadGameOverLeaderboard();

            // Show the overlay
            gameOverOverlay.style.display = 'flex'; // Use flex for centering
        }

        async function loadGameOverLeaderboard() {
            const leaderboardBody = document.getElementById('game-over-leaderboard-body'); // Changed ID back
            if (!leaderboardBody) {
                console.error("Leaderboard body element not found.");
                return;
            }
            if (!db) {
                console.error("DB not ready in loadGameOverLeaderboard. Cannot load leaderboard.");
                leaderboardBody.innerHTML = '<tr><td colspan="3">Error: Firestore not ready.</td></tr>';
                return; // Don't proceed if db isn't ready
            }

            leaderboardBody.innerHTML = '<tr><td colspan="3" style="text-align:center;">Loading...</td></tr>'; // Show loading state
            console.log("Attempting to load leaderboard from Firestore...");

            try {
                const querySnapshot = await db.collection("leaderboard")
                                              .orderBy("score", "desc")
                                              .limit(100) // Fetch top 100
                                              .get();

                leaderboardBody.innerHTML = ''; // Clear loading/previous state
                if (querySnapshot.empty) {
                    leaderboardBody.innerHTML = '<tr><td colspan="3" style="text-align: center;">Leaderboard is empty.</td></tr>';
                    return;
                }

                let rank = 1;
                querySnapshot.forEach((doc) => {
                    const data = doc.data();
                    const row = leaderboardBody.insertRow();
                    const rankCell = row.insertCell(0);
                    const nameCell = row.insertCell(1);
                    const scoreCell = row.insertCell(2);

                    rankCell.textContent = rank++;
                    nameCell.textContent = data.name || "Anonymous"; // Handle missing names
                    scoreCell.textContent = data.score;

                    // Optional: Highlight the player's score if just saved? Requires more complex logic.
                });
            } catch (error) {
                console.error("Error loading game over leaderboard: ", error); // Log specific error
                leaderboardBody.innerHTML = '<tr><td colspan="3" style="text-align: center;">Error loading leaderboard.</td></tr>';
            }
        }

        async function submitScore() {
            const playerName = playerNameInput.value.trim();

            if (!playerName) {
                saveStatusMessage.textContent = 'Please enter a name.';
                saveStatusMessage.style.color = 'red';
                playerNameInput.focus();
                return;
            }

            if (score <= 0) {
                 saveStatusMessage.textContent = 'No score to save.';
                 saveStatusMessage.style.color = 'orange';
                 return;
            }

            if (!db) { // Double check db before submitting
                console.error("DB not ready in submitScore. Cannot save.");
                saveStatusMessage.textContent = 'Error: Cannot connect to save.';
                 saveStatusMessage.style.color = 'red';
                return;
            }

            // Disable input/button during save
            playerNameInput.disabled = true;
            submitScoreButton.disabled = true;
            submitScoreButton.textContent = 'Saving...';
            saveStatusMessage.textContent = 'Submitting score...';
            saveStatusMessage.style.color = 'lime'; // Reset color

            try {
                await db.collection("leaderboard").add({
                    name: playerName,
                    score: score,
                    timestamp: firebase.firestore.FieldValue.serverTimestamp()
                });

                console.log("Score saved successfully by user!");
                saveStatusMessage.textContent = 'Score Saved!';
                saveStatusMessage.style.color = '#aaffaa'; // Success green
                // Button/input remain disabled after successful save for this session

                // Refresh the leaderboard displayed in the overlay
                loadGameOverLeaderboard();

            } catch (error) {
                console.error("Error saving score: ", error); // Log specific error
                saveStatusMessage.textContent = 'Error saving score. Please try again.';
                saveStatusMessage.style.color = 'red';
                // Re-enable on error
                playerNameInput.disabled = false;
                submitScoreButton.disabled = false;
                submitScoreButton.textContent = 'Save Score';
            }
        }

        function restartGame() {
            console.log("DEBUG: restartGame called.");
            gameOverOverlay.style.display = 'none';
            saveScoreSection.style.display = 'none'; // Corrected variable: Hide save score section on restart
            submitScoreButton.disabled = false; // Corrected variable: Re-enable button
            submitScoreButton.textContent = 'Save Score'; // Corrected variable: Reset button text
            // Clear the board array completely using correct dimensions
            board = Array(boardHeight).fill(0).map(() => Array(boardWidth).fill(0)); // Corrected: Use boardHeight and boardWidth
            console.log("Board reset in restartGame.");
            // <<< ADDED DEBUG LOGGING >>>
            console.log("Board state immediately after reset (Top 4 rows):");
            for (let i = 0; i < Math.min(4, boardHeight); i++) {
                console.log(`Row ${i}:`, JSON.stringify(board[i]));
            }
            console.log(`Board dimensions: ${boardHeight}x${boardWidth}`);
            // <<< END ADDED DEBUG LOGGING >>>
            setup(false); // Re-setup the game without initial settings load
            // No need to call gameLoop here, setup(false) handles it if needed
        }

        // <<< ADDED PAUSE MENU ELEMENT INITIALIZATION FUNCTION >>>
        function initializePauseMenuElements() {
            pauseMenuElements = {}; // Clear previous elements
            const tempCtx = canvas.getContext('2d'); // Need context for measuring text
            if (!tempCtx) return; // Safety check

            const centerX = width / 2;
            let currentY = height * 0.3; // Start below title

            // Close Button (Top Right)
            pauseMenuCloseButtonRect = {
                x: width - PAUSE_MENU_CLOSE_BUTTON_SIZE - PAUSE_MENU_CLOSE_BUTTON_MARGIN,
                y: PAUSE_MENU_CLOSE_BUTTON_MARGIN,
                width: PAUSE_MENU_CLOSE_BUTTON_SIZE,
                height: PAUSE_MENU_CLOSE_BUTTON_SIZE
            };
            pauseMenuElements['closeButton'] = {
                type: 'closeButton',
                rect: pauseMenuCloseButtonRect
            };

            const sliderWidth = width * PAUSE_MENU_SLIDER_WIDTH_RATIO;
            const sliderX = centerX - sliderWidth / 2;

            // Ghost Transparency Slider
            pauseMenuElements['ghostSlider'] = {
                type: 'slider',
                label: 'Ghost Transparency', // <<< CHANGED LABEL
                setting: 'ghostAlpha',
                rect: { x: sliderX, y: currentY, width: sliderWidth, height: PAUSE_MENU_SLIDER_HEIGHT },
                min: 0.01, max: 0.15
            };
            currentY += PAUSE_MENU_ITEM_GAP;

            // Background Transparency Slider
            pauseMenuElements['bgSlider'] = {
                type: 'slider',
                label: 'BG Transparency', // <<< CHANGED LABEL
                setting: 'boardBackgroundAlpha',
                rect: { x: sliderX, y: currentY, width: sliderWidth, height: PAUSE_MENU_SLIDER_HEIGHT },
                min: 0.1, max: 1.0
            };
            currentY += PAUSE_MENU_ITEM_GAP;

            // Buttons - Calculate positions dynamically
            tempCtx.font = `${PAUSE_MENU_ITEM_FONT_SIZE}px monospace`;
            const buttonWidthEstimate = tempCtx.measureText("Wireframe: OFF").width + PAUSE_MENU_BUTTON_PADDING_X * 2;
            const buttonHeight = PAUSE_MENU_ITEM_FONT_SIZE + PAUSE_MENU_BUTTON_PADDING_Y * 2;
            let buttonX = centerX - buttonWidthEstimate / 2;

            // SFX Button
             pauseMenuElements['sfxButton'] = {
                type: 'button',
                label: () => `SFX: ${settings_sfxEnabled ? 'ON' : 'OFF'}`, // Dynamic label
                setting: 'sfxEnabled',
                rect: { x: buttonX, y: currentY, width: buttonWidthEstimate, height: buttonHeight }
            };
            currentY += PAUSE_MENU_ITEM_GAP * 0.8;

            // Wireframe Button
            pauseMenuElements['wireframeButton'] = {
                type: 'button',
                label: () => `Wireframe: ${settings_useWireframeBlocks ? 'ON' : 'OFF'}`, // Dynamic label
                setting: 'useWireframeBlocks',
                 rect: { x: buttonX, y: currentY, width: buttonWidthEstimate, height: buttonHeight }
            };
             currentY += PAUSE_MENU_ITEM_GAP * 0.8;

            // Fullscreen Button
            pauseMenuElements['fullscreenButton'] = {
                type: 'button',
                label: () => (document.fullscreenElement || document.webkitFullscreenElement) ? "Exit Fullscreen" : "Enter Fullscreen", // Dynamic label
                action: 'toggleFullscreen', // Specific action, not setting
                 rect: { x: buttonX, y: currentY, width: buttonWidthEstimate, height: buttonHeight }
            };
             currentY += PAUSE_MENU_ITEM_GAP; // Add more space before leaderboard

            // Leaderboard Area
            const leaderboardHeight = height * 0.25; // Example height (adjust as needed)
            const leaderboardWidth = width * 0.6;  // Example width
            const leaderboardX = centerX - leaderboardWidth / 2;
            pauseMenuElements['leaderboard'] = {
                type: 'leaderboard',
                label: 'Leaderboard (Top 100)',
                rect: { x: leaderboardX, y: currentY, width: leaderboardWidth, height: leaderboardHeight }
            };
            // Note: currentY is not incremented further unless more elements are added below

            console.log("Pause menu elements initialized:", pauseMenuElements);
        }
         // <<< END ADDED FUNCTION >>>

        // <<< ADDED LEADERBOARD LOADING FUNCTION FOR PAUSE MENU >>>
        async function loadPauseMenuLeaderboard() {
            if (!db) {
                console.error("DB not ready, cannot load pause menu leaderboard.");
                pauseLeaderboardData = [{ rank: '', name: 'Error: DB not ready', score: '' }];
                return;
            }
            console.log("Loading pause menu leaderboard...");
            pauseLeaderboardData = [{ rank: '', name: 'Loading...', score: '' }]; // Set loading state
            try {
                const querySnapshot = await db.collection("leaderboard")
                                              .orderBy("score", "desc")
                                              .limit(100)
                                              .get();

                if (querySnapshot.empty) {
                    pauseLeaderboardData = [{ rank: '', name: 'Leaderboard empty', score: '' }];
                    return;
                }

                let rank = 1;
                const scores = [];
                querySnapshot.forEach((doc) => {
                    const data = doc.data();
                    scores.push({ rank: rank++, name: data.name || "???", score: data.score });
                });
                pauseLeaderboardData = scores;
                console.log("Pause leaderboard loaded:", pauseLeaderboardData.length, "entries");
            } catch (error) {
                console.error("Error loading pause menu leaderboard: ", error);
                pauseLeaderboardData = [{ rank: '', name: 'Error loading scores', score: '' }];
            }
        }

        function drawPauseMenu(timestamp) { // <<< Added timestamp parameter
            if (!ctx || !width || !height || !pauseMenuInitialized) return;

            ctx.fillStyle = `rgba(0, 0, 0, ${PAUSE_MENU_BG_ALPHA})`;
            ctx.fillRect(0, 0, width, height);

            ctx.font = `bold ${PAUSE_MENU_TITLE_FONT_SIZE}px monospace`;
            ctx.fillStyle = PAUSE_MENU_TEXT_COLOR;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            const titleY = height * 0.15;
            // Apply glitch effect to title
            let titleText = "PAUSED";
            if (Math.random() < 0.08) { // Add some glitch
                titleText = glitchText(titleText, 0.2);
            }
            ctx.fillText(titleText, width / 2, titleY);

            // Draw elements
            for (const key in pauseMenuElements) {
                const el = pauseMenuElements[key];
                if (!el || !el.rect) continue;

                // Add subtle shimmer/flicker to elements
                const flicker = Math.random() < 0.008;
                const baseColor = PAUSE_MENU_TEXT_COLOR;
                const elementColor = flicker ? '#ffffff' : baseColor;
                const borderColor = flicker ? 'rgba(200, 255, 200, 0.9)' : 'rgba(0, 100, 0, 1)';
                const handleColor = (activeSlider === key) ? '#ffffaa' : (flicker ? '#ddffdd' : '#aaffaa');

                if (el.type === 'slider') {
                    // ... (Draw Label with elementColor) ...
                    ctx.font = `${PAUSE_MENU_ITEM_FONT_SIZE}px monospace`;
                    ctx.fillStyle = elementColor; // Use themed color
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';
                    ctx.fillText(el.label, width / 2, el.rect.y - 5);

                    // ... (Draw Slider Track with themed border) ...
                    ctx.fillStyle = 'rgba(0, 50, 0, 0.8)';
                    ctx.fillRect(el.rect.x, el.rect.y, el.rect.width, el.rect.height);
                    ctx.strokeStyle = borderColor; // Use themed border color
                    ctx.lineWidth = 1;
                    ctx.strokeRect(el.rect.x, el.rect.y, el.rect.width, el.rect.height);

                    // ... (Draw Slider Handle with themed color) ...
                    let currentVal = 0;
                    if (el.setting === 'ghostAlpha') currentVal = settings_ghostAlpha;
                    else if (el.setting === 'boardBackgroundAlpha') currentVal = settings_boardBackgroundAlpha;
                    const ratio = clamp((currentVal - el.min) / (el.max - el.min), 0, 1);
                    const handleX = el.rect.x + ratio * el.rect.width;
                    const handleY = el.rect.y + el.rect.height / 2;
                    el.handleX = handleX;
                    el.handleY = handleY;
                    ctx.fillStyle = handleColor; // Use themed handle color
                    ctx.beginPath();
                    ctx.arc(handleX, handleY, PAUSE_MENU_SLIDER_HANDLE_SIZE / 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
                    ctx.stroke();

                    // ... (Draw Value Text with elementColor) ...
                    ctx.font = `${PAUSE_MENU_VALUE_FONT_SIZE}px monospace`;
                    ctx.fillStyle = elementColor; // Use themed color
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                    ctx.fillText(currentVal.toFixed(2), width / 2, el.rect.y + el.rect.height + 5);

                } else if (el.type === 'button') {
                    // ... (Draw Button Background with themed border) ...
                    ctx.fillStyle = 'rgba(0, 50, 0, 0.8)';
                    ctx.fillRect(el.rect.x, el.rect.y, el.rect.width, el.rect.height);
                    ctx.strokeStyle = borderColor; // Use themed border color
                    ctx.lineWidth = 1;
                    ctx.strokeRect(el.rect.x, el.rect.y, el.rect.width, el.rect.height);

                    // ... (Draw Button Text with elementColor and potential glitch) ...
                    ctx.font = `${PAUSE_MENU_ITEM_FONT_SIZE}px monospace`;
                    ctx.fillStyle = elementColor; // Use themed color
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    let buttonText = typeof el.label === 'function' ? el.label() : el.label;
                    if (flicker || Math.random() < 0.02) buttonText = glitchText(buttonText, 0.15);
                    ctx.fillText(buttonText, el.rect.x + el.rect.width / 2, el.rect.y + el.rect.height / 2);

                } else if (el.type === 'closeButton') {
                    // ... (Draw Close Button Background with themed border) ...
                    ctx.fillStyle = 'rgba(50, 0, 0, 0.8)';
                    ctx.fillRect(el.rect.x, el.rect.y, el.rect.width, el.rect.height);
                    ctx.strokeStyle = flicker ? 'rgba(255, 100, 100, 0.9)' : 'rgba(100, 0, 0, 1)'; // Red themed border
                    ctx.lineWidth = 1;
                    ctx.strokeRect(el.rect.x, el.rect.y, el.rect.width, el.rect.height);

                    // ... (Draw 'X' with themed color) ...
                    ctx.strokeStyle = flicker ? '#ffffff' : '#ffaaaa'; // Red themed X
                    ctx.lineWidth = 3;
                    const padding = el.rect.width * 0.25;
                    ctx.beginPath();
                    ctx.moveTo(el.rect.x + padding, el.rect.y + padding);
                    ctx.lineTo(el.rect.x + el.rect.width - padding, el.rect.y + el.rect.height - padding);
                    ctx.moveTo(el.rect.x + el.rect.width - padding, el.rect.y + padding);
                    ctx.lineTo(el.rect.x + padding, el.rect.y + el.rect.height - padding);
                    ctx.stroke();
                } else if (el.type === 'leaderboard') {
                    // Draw Leaderboard Title
                    ctx.font = `${PAUSE_MENU_ITEM_FONT_SIZE * 0.9}px monospace`; // Slightly smaller
                    ctx.fillStyle = elementColor;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';
                    ctx.fillText(el.label, el.rect.x + el.rect.width / 2, el.rect.y - 3);

                    // Draw Container Box
                    ctx.fillStyle = 'rgba(0, 15, 0, 0.7)';
                    ctx.fillRect(el.rect.x, el.rect.y, el.rect.width, el.rect.height);
                    ctx.strokeStyle = borderColor;
                    ctx.lineWidth = 1;
                    ctx.strokeRect(el.rect.x, el.rect.y, el.rect.width, el.rect.height);

                    // <<< ADDED LEADERBOARD DRAWING LOGIC with LOGGING >>>
                    console.log(`[DrawPauseMenu] Leaderboard Data:`, pauseLeaderboardData ? `${pauseLeaderboardData.length} entries` : 'null', `ScrollY: ${pauseLeaderboardScrollY.toFixed(1)}`); // Log data state and scroll
                    ctx.save();
                    ctx.beginPath(); // Define the clipping path
                    ctx.rect(el.rect.x, el.rect.y, el.rect.width, el.rect.height);
                    ctx.closePath();
                    ctx.clip(); // Clip subsequent drawing to the leaderboard rect

                    ctx.font = `${PAUSE_MENU_VALUE_FONT_SIZE * 0.8}px monospace`; // Very small text
                    ctx.fillStyle = elementColor;
                    ctx.textAlign = 'left';
                    ctx.textBaseline = 'top';

                    if (pauseLeaderboardData && Array.isArray(pauseLeaderboardData) && pauseLeaderboardData.length > 0) {
                        let drawY = el.rect.y + 5 - pauseLeaderboardScrollY; // Start drawing based on scroll
                        const lineHeight = PAUSE_MENU_VALUE_FONT_SIZE * 0.9; // Line height for small text
                        let drawnCount = 0; // Counter for drawn entries

                        for (const entry of pauseLeaderboardData) {
                            // Basic check for valid entry structure
                            if (typeof entry !== 'object' || entry === null || typeof entry.rank === 'undefined' || typeof entry.name === 'undefined' || typeof entry.score === 'undefined') {
                                console.warn("[DrawPauseMenu] Skipping invalid leaderboard entry:", entry);
                                continue; // Skip malformed entries
                            }

                            // Only draw if visible within the rect
                            if (drawY >= el.rect.y - lineHeight && drawY < el.rect.y + el.rect.height) {
                                let rankStr = entry.rank.toString().padStart(3);
                                let scoreStr = entry.score.toString().padStart(7);
                                let nameStr = entry.name.padEnd(12).substring(0, 12); // Pad/truncate name
                                let textLine = `${rankStr} ${nameStr} ${scoreStr}`;
                                if (Math.random() < 0.01) textLine = glitchText(textLine, 0.1); // Add glitch to entries too

                                // LOGGING INSIDE LOOP:
                                // console.log(`[DrawPauseMenu] Drawing entry: ${rankStr} at drawY: ${drawY.toFixed(1)}`);

                                ctx.fillText(textLine, el.rect.x + 5, drawY);
                                drawnCount++;
                            }
                            drawY += lineHeight;
                            // Optimization: Stop drawing if we are already past the bottom visible edge
                            if (drawY > el.rect.y + el.rect.height + lineHeight) {
                               // console.log(`[DrawPauseMenu] Stopping draw loop early at drawY: ${drawY.toFixed(1)}`);
                                break;
                            }
                        }
                        // Log if no entries were actually drawn despite having data
                        if (drawnCount === 0 && pauseLeaderboardData.length > 0) {
                             console.warn(`[DrawPauseMenu] Leaderboard data exists (${pauseLeaderboardData.length} entries), but none were drawn. Check scroll/coordinates. First entry drawY would be: ${el.rect.y + 5 - pauseLeaderboardScrollY}`);
                        }
                    } else if (pauseLeaderboardData && pauseLeaderboardData.length === 1 && pauseLeaderboardData[0].name.includes('Loading')) {
                         ctx.textAlign = 'center';
                         ctx.fillText("Loading...", el.rect.x + el.rect.width / 2, el.rect.y + el.rect.height / 2 - lineHeight / 2);
                         ctx.textAlign = 'left'; // Reset alignment
                    } else if (pauseLeaderboardData && pauseLeaderboardData.length === 1 && pauseLeaderboardData[0].name.includes('Error')) {
                         ctx.textAlign = 'center';
                         ctx.fillText("Error loading", el.rect.x + el.rect.width / 2, el.rect.y + el.rect.height / 2 - lineHeight);
                         ctx.fillText("leaderboard", el.rect.x + el.rect.width / 2, el.rect.y + el.rect.height / 2);
                         ctx.textAlign = 'left'; // Reset alignment
                    } else {
                         ctx.textAlign = 'center';
                         ctx.fillText("No scores yet.", el.rect.x + el.rect.width / 2, el.rect.y + el.rect.height / 2 - lineHeight / 2);
                         ctx.textAlign = 'left'; // Reset alignment
                    }

                    ctx.restore(); // Remove clipping path
                    // <<< END LEADERBOARD DRAWING LOGIC >>>
                }
            }

            ctx.textAlign = 'left';
            ctx.textBaseline = 'alphabetic';
        }
        // <<< END REPLACED FUNCTION >>>

    })(); // End of IIFE

    </script>
    <!-- Removed conflict markers from end of file -->
</body>
</html>